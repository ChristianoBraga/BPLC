\documentclass{beamer}
\usepackage{pythonhighlight}
\usepackage{syntax}
\newcommand{\BS}{\char`\\}
\grammarindent=0.28\textwidth
\usepackage{fourier}
\usepackage{tikz}
\usetikzlibrary{arrows,shapes,decorations,automata,backgrounds,positioning}
\usepackage{upgreek} % For \uppi
\usepackage{adjustbox}
%\usepackage{subfigure}
\usepackage{proof}
\usepackage{bbm}
\usepackage{listings}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}\definecolor{LtGray}{rgb}{0.95,0.95,0.95}

\lstset{%
%language=Java,			% choose the language of the code
basicstyle=\scriptsize,	% the size of the fonts that are used for the code
columns=fullflexible,
mathescape=true,
tabsize=2, linewidth=\textwidth, 
numbers=left,				% where to put the line-numbers
numberstyle=\tiny,			% the size of the fonts that are used for the line-numbers
stepnumber=1,				% the step between two line-numbers. If it's 1 each line will be numbered
numbersep=5pt,			% how far the line-numbers are from the code
backgroundcolor=\color{LtGray},% choose the background color. You must add \usepackage{color}
showspaces=false,			% show spaces adding particular underscores
showstringspaces=false,		% underline spaces within strings
showtabs=false,			% show tabs within strings adding particular underscores
frame=lines,				% adds a frame around the code
tabsize=2,					% sets default tabsize to 2 spaces
captionpos=b,				% sets the caption-position to bottom
floatplacement={tbp},
breaklines=true,			% sets automatic line breaking
breakatwhitespace=false,		% sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)},		% if you want to add a comment within your code
numberbychapter=false
}

\lstdefinestyle{padrao}{%
%language=Java,			% choose the language of the code
basicstyle=\scriptsize,	% the size of the fonts that are used for the code
columns=fullflexible,
mathescape=true,
tabsize=2, linewidth=\textwidth, 
numbers=left,				% where to put the line-numbers
numberstyle=\tiny,			% the size of the fonts that are used for the line-numbers
stepnumber=1,				% the step between two line-numbers. If it's 1 each line will be numbered
numbersep=5pt,			% how far the line-numbers are from the code
backgroundcolor=\color{LtGray},% choose the background color. You must add \usepackage{color}
showspaces=false,			% show spaces adding particular underscores
showstringspaces=false,		% underline spaces within strings
showtabs=false,			% show tabs within strings adding particular underscores
frame=lines,				% adds a frame around the code
tabsize=2,					% sets default tabsize to 2 spaces
captionpos=b,				% sets the caption-position to bottom
floatplacement={tbp},
breaklines=true,			% sets automatic line breaking
breakatwhitespace=false,		% sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)},		% if you want to add a comment within your code
numberbychapter=false
}

\lstdefinestyle{maudedef}{%
%language=Java,			% choose the language of the code
basicstyle=\scriptsize\sffamily,	% the size of the fonts that are used for the code
columns=fullflexible,
mathescape=true,
tabsize=2, linewidth=\textwidth, 
showspaces=false,			% show spaces adding particular underscores
showstringspaces=false,		% underline spaces within strings
showtabs=false,			% show tabs within strings adding particular underscores
tabsize=2,					% sets default tabsize to 2 spaces
captionpos=b,				% sets the caption-position to bottom
floatplacement={tbp},
breaklines=true,			% sets automatic line breaking
breakatwhitespace=false,		% sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)}		% if you want to add a comment within your code
}

\lstdefinelanguage{maude}{
 keywords={pr, ex, inc, fmod, endfm, mod, is, endm, sort, sorts, subsort, op, ops, eq, rl, ceq, if, then, else, fi, crl, assoc, comm, ctor, id, var, vars, mb, cmb}
}
\lstnewenvironment{maude}[1][]{\lstset{language=maude,style=padrao,#1}}{}
\lstnewenvironment{maudedef}[1][]{\lstset{language=maude,style=maudedef,#1}}{}


\DeclareOptionBeamer{compress}{\beamer@compresstrue}
\ProcessOptionsBeamer

\mode<presentation>

\useoutertheme{infolines}
\useinnertheme{circles}
\usecolortheme{whale}
\usecolortheme{orchid}

\definecolor{blendedgreen}{rgb}{0,0.741,0.466}
\definecolor{green}{rgb}{0,0.4,0}

\setbeamercolor{structure}{fg=blendedgreen}
\setbeamercolor{titlelike}{parent=structure}
\setbeamercolor{frametitle}{fg=black}
\setbeamercolor{title}{fg=black}
\setbeamercolor{item}{fg=black}
\setbeamertemplate{caption}{\raggedright\insertcaption\par}

% Suppresses the ball and keeps the numbers in toc.
\setbeamertemplate{section in toc}{\inserttocsectionnumber.~\inserttocsection}

% Remove navigation buttons.
\beamertemplatenavigationsymbolsempty

\mode<all>

\logo{\includegraphics[width=0.1\textwidth]{LogoIC-final.jpg}}

\usepackage{url}

\title[Compiler Construction with $\uppi$]{Notes on Formal Compiler Construction with the \\ \color{red}{$\uppi$ Framework}}
\author[C. Braga]{Christiano Braga} 
\institute[IC/UFF]{Instituto de Computa\c{c}\~ao, \\ Universidade Federal Fluminense, Niter\'oi, Brazil \\
}

\date{\today} 
\begin{document}

% ---

\begin{frame}[plain]

\titlepage

\begin{center}
\color{red}{\url{http://github.com/ChristianoBraga/PiFramework}}
\end{center}

\[\includegraphics[width=0.2\textwidth]{LogoIC-final.jpg}\]

\end{frame}

% ---

\begin{frame}[plain]

\tableofcontents

\end{frame}


% ---

%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%

\begin{frame}{Compiler pipeline}

\begin{adjustbox}{width=\textwidth,center}
$\begin{array}{ccccccccccccc}
source  & \xrightarrow{lexer} & tokens & \xrightarrow{parser} & concrete & \xrightarrow{AST \ transformer} & abstract & \xrightarrow{type \ checker} & abstract & \xrightarrow{code \ generator} & machine & \xrightarrow{optimizer} & optimized \\
code    &            &        &             & syntax   &                      & syntax   &                   & syntax   &                     & code    & & machine \\
        &            &        &             & tree     &                      & tree     &                   & tree     &                     &         & & code
\end{array}$
\end{adjustbox}
\end{frame}

% --- 

\begin{frame}{Compiler pipeline and formal languages}

\begin{adjustbox}{width=\textwidth,center}
$\begin{array}{ccccccccccccc}
        & Regular         &        & Context Free &          & Context Free         &          & Context Sensitive &          & Turing              &         & Turing & \\
	& Grammar         &        & Grammar       &          & Grammar              &          & Grammar           &          & Machine             &         & Machine & \\
source  & \xrightarrow{lexer} & tokens & \xrightarrow{parser}  & concrete & \xrightarrow{AST \ transformer} & abstract & \xrightarrow{type \ checker} & abstract & \xrightarrow{code \ generator} & machine & \xrightarrow{optimizer} & optimized \\
code    &                 &        &              & syntax   &                      & syntax   &                   & syntax   &                     & code    & & machine \\
        &                 &        &              & tree     &                      & tree     &                   & tree     &                     &         & & code
\end{array}$
\end{adjustbox}

\end{frame}

% --- 

\begin{frame}[shrink]{Compiler pipeline with the {\color{red}$\uppi$ Framework}}

\begin{adjustbox}{width=\textwidth,center}
$\begin{array}{ccccccccc}
             &                                                                                                                                                                                                                                                                                             &               &  \color{red}{\uppi} & \\
	     &                                                                                                                                                                                                                                                                                             &               &  \color{red}{Automata} & \\ \\
	     &                                                                           {\tiny Chomsky's \ hierarchy}                                                                                                                                                                                                                  &               &  \xrightarrow{interpreter} & output \\     
source  & {\tiny \xrightarrow{lexer} \circ \xrightarrow{parser}  \circ \xrightarrow{\stackrel{AST}{transformer}} \circ \xrightarrow{\stackrel{type}{checker}} \circ \xrightarrow{\stackrel{code}{generator}}} & \color{red}{\uppi \ lib} & \xrightarrow{code \ generator} & machine \ code \\
code             &                                                                                                                                                                                                                                                                                            &                 & \xrightarrow{model \ checker(P)} & counter\mbox{-}examples  \\
            &                                                                                                                                                                                                                                                                                             &                 & \text{\tiny where $P$ is a property}        &    \\
            &                                                                                                                                                                                                                                                                                             &                 & \text{\tiny in a suitable logic.}        &   \\           
\end{array}$
\end{adjustbox}

\begin{itemize}
\item {\color{red}$\uppi$ lib} defines a set of constructions common to many programming languages.
\item {\color{red}$\uppi$ lib} constructions have a formal automata-based semantics in {\color{red}$\uppi$ automata}.
\item One may execute (or validate) a program in a given language by running its associated {\color{red}$\uppi$ lib} program. 
\item {\color{red}$\uppi$ Framework}: \url{http://github.com/ChristianoBraga/PiFramework}
\item Notes on Formal Compiler Construction with the {\color{red}$\uppi$ Framework}: \url{https://github.com/ChristianoBraga/PiFramework/blob/master/notes/notes.pdf}.
\end{itemize}

\end{frame}

%%%%%%%%%%%%
\subsection{Example}
%%%%%%%%%%%%

% ---
\begin{frame}[fragile]{A calculator}

We wish to compute simple arithmetic expressions such as $ 5 * (3 + 2)$.

\end{frame}

% ---

\begin{frame}[fragile]{A calculator: Lexer}
\begin{grammar}
<digit> ::= [0..9]

<digits> ::= <digit>$^+$

<boolean> ::= `true' | `false'
\end{grammar}
\end{frame}

% ---

\begin{frame}[fragile]{A calculator: concrete syntax}
\begin{grammar}
<exp> ::= <aexp> | <bexp>

<aexp> ::= <aexp> `+' <term> | <aexp> `-' <term> | <term>

<term> ::= <term> `*' <factor> | <term> `/' <factor> | <factor>

<factor> ::= `(' <aexp> `)'  | <digits>

<bexp> ::= <boolean> | `~' <bexp> | <bexp> <boolop> <bexp> 
\alt <aexp> <iop> <aexp>

<boolop> ::= `=' | `/\BS' | `\BS/'

<iop> ::= `<' | `>' | `<=' | `>=' 
\end{grammar}
\end{frame}

% ---

\begin{frame}[fragile]{A calculator: abstract syntax}
\begin{grammar}
<exp> ::= <digits> | <boolean> | <exp> <bop> <exp> 

<bop> ::= `+' | `-' | `*' | `/' | `=' | `\BS/`| `/\BS' | `<' | `>' | `<=' | `>=' 
\end{grammar}
\end{frame}

% ---

\begin{frame}[fragile, allowframebreaks]{A calculator: {\color{red}$\uppi$} denotations}
Let $D$ in <digits>, $B$ in <boolean> and $E_1, E_2$ in <exp>,

\begin{footnotesize}
\begin{align}
\label{eq:dig}\llbracket D \rrbracket_{\uppi} & = Num(D) \\
\llbracket B \rrbracket_{\uppi} & = Boo(B) \\
\label{eq:add}\llbracket E_1 + E_2 \rrbracket_{\uppi} & = Sum(\llbracket E_1 \rrbracket_{\uppi}, \llbracket E_2 \rrbracket_{\uppi}) \\
\llbracket E_1 - E_2 \rrbracket_{\uppi} & = Sub(\llbracket E_1 \rrbracket_{\uppi}, \llbracket E_2 \rrbracket_{\uppi}) \\
\label{eq:mul}\llbracket E_1 * E_2 \rrbracket_{\uppi} & = Mul(\llbracket E_1 \rrbracket_{\uppi}, \llbracket E_2 \rrbracket_{\uppi}) \\
\llbracket E_1 / E_2 \rrbracket_{\uppi} & = Div(\llbracket E_1 \rrbracket_{\uppi}, \llbracket E_2 \rrbracket_{\uppi}) \\
\llbracket E_1 < E_2 \rrbracket_{\uppi} & = Lt(\llbracket E_1 \rrbracket_{\uppi}, \llbracket E_2 \rrbracket_{\uppi}) \\
\llbracket E_1 {<=} E_2 \rrbracket_{\uppi} & = Le(\llbracket E_1 \rrbracket_{\uppi}, \llbracket E_2 \rrbracket_{\uppi}) \\
\llbracket E_1 > E_2 \rrbracket_{\uppi} & = Gt(\llbracket E_1 \rrbracket_{\uppi}, \llbracket E_2 \rrbracket_{\uppi}) \\
\llbracket E_1 {>\!=} E_2 \rrbracket_{\uppi} & = Ge(\llbracket E_1 \rrbracket_{\uppi}, \llbracket E_2 \rrbracket_{\uppi}) 
\end{align}
\end{footnotesize}

\framebreak 

\begin{itemize}
\item {\color{red}$\uppi$} denotations are \emph{functions} $\llbracket \cdot \rrbracket_\uppi : \mathit{AST} \to \uppi \ \mathit{lib}$, where 
\emph{AST} denotes the \emph{datatype} for the abstract syntax tree and $\uppi \ \mathit{lib}$ denotes the datatype for {\color{red}$\uppi \ \mathit{lib}$} programs. 
\item Note that $\llbracket \cdot \rrbracket_\uppi$ has \emph{trees} as parameters, instances of \emph{AST}. The example expression $5 * (3 + 2)$ becomes

\begin{adjustbox}{width=0.7\textwidth,center}
\begin{tikzpicture}[node distance=2.5cm,>=stealth', on grid]
\node (exp1) {$e_1$ : <exp>};
\node (exp2) [below left of = exp1] {$e_2$ : <exp>} ; 
\node (d1) [below of = exp2] {$5$ : <digits>} ; 
\node (op1) [right of = exp2] {* : <bop>} ;  
\node (exp3) [right of = op1] {$e_3$ : <exp>} ; 
\node (exp4) [right of = d1] {$e_4$ : <exp>} ; 
\node (d2) [below of = exp4] {$3$ : <digits>} ; 
\node (op2) [right of = exp4] {+ : <bop>} ;  
\node (exp5) [right of = op2] {$e_5$ : <exp>} ; 
\node (d3) [below of = exp5] {$2$ : <digits>} ; 

\path (exp1) edge node {} (exp2) edge node {} (op1) edge node {} (exp3) ;
\path (exp2) edge node {} (d1) ;
\path (exp3) edge node {} (exp4) edge node {} (op2) edge node {} (exp5) ;
\path (exp4) edge node {} (d2) ;
\path (exp5) edge node {} (d3) ; 
\end{tikzpicture}
\end{adjustbox}

\end{itemize}

\framebreak

\begin{footnotesize}
\begin{align*}
\llbracket 5 * (3 + 2) \rrbracket_{\uppi} & = Mul(\llbracket 5 \rrbracket_\uppi, \llbracket (3 + 2) \rrbracket_{\uppi}) & by \ Equation~\ref{eq:mul} \\
Mul(\llbracket 5 \rrbracket_\uppi, \llbracket (3 + 2) \rrbracket_{\uppi}) & = Mul(Num(5), \llbracket (3 + 2) \rrbracket_{\uppi}) & by \ Equations~\ref{eq:dig} \\
Mul(num(5), \llbracket (3 + 2) \rrbracket_{\uppi}) & = Mul(Num(5), Sum(\llbracket 3 \rrbracket_\uppi, \llbracket 2 \rrbracket_\uppi)  & by \ Equation~\ref{eq:add} \\
Mul(Num(5), Sum(\llbracket 3 \rrbracket_\uppi, \llbracket 2 \rrbracket_\uppi)  & =  Mul(Num(5), Sum(Num(3), \llbracket 2 \rrbracket_\uppi) & by \ Equation~\ref{eq:dig} \\
Mul(Num(5), Sum(Num(3), \llbracket 2 \rrbracket_\uppi)  & =  Mul(Num(5), Sum(Num(3), Num(2)) & by \ Equation~\ref{eq:dig} 
\end{align*}
\end{footnotesize}

\end{frame}

% --- 

\begin{frame}{A calculator: executing {\color{red}$\uppi$ lib} with {\color{red}$\uppi$ automata}}

A {\color{red}$\uppi$ automaton} is a $5$-tuple $\mathcal{A} = (G, Q, \delta, q_0, F)$, where $G$ is a context-free grammar, $Q$ is the set of states, $q_0$ is the initial state, $F \subseteq Q$ is the set of final states and
$$\delta : L(G)^* \times L(G)^* \times Store \to Q,$$ where $L(G)$ is the language generated by $G$ and $\mathit{Store}$ represents the memory. (Elements in a set $S^*$ are represented by terms $[s_1, s_2, \ldots, s_n]$.)

\begin{tiny}
\begin{align*}
\delta([Mul(Num(5), Sum(Num(3), Num(2)], \emptyset, \emptyset) & =  \delta([Num(5), Sum(Num(3), Num(2)), \#MUL], \emptyset, \emptyset) \\
\delta([Num(5), Sum(Num(3), Num(2)), \#MUL], \emptyset, \emptyset) & = \delta([Sum(Num(3), Num(2)), \#MUL], [Num(5)], \emptyset) \\ 
\delta([Sum(Num(3), Num(2)), \#MUL], [Num(5)], \emptyset) & = \delta([Num(3), Num(2), \#SUM, \#MUL], [Num(5)], \emptyset) \\
\delta([Num(3), Num(2), \#SUM, \#MUL], [Num(5)], \emptyset) & = \delta([Num(2), \#SUM, \#MUL], [Num(3), Num(5)], \emptyset) \\
\delta([Num(2), \#SUM, \#MUL], [Num(3), Num(5)], \emptyset) & = \delta([\#SUM, \#MUL], [Num(2), Num(3), Num(5)], \emptyset) \\
\delta([\#SUM, \#MUL], [Num(2), Num(3), Num(5)], \emptyset) & = \delta([\#MUL], [Num(5), Num(5)], \emptyset) \\
\delta([\#MUL], [Num(5), Num(5)], \emptyset) & = \delta(\emptyset, [Num(25)], \emptyset) \\
\delta(\emptyset, [Num(25)], \emptyset) & = Num(25)
\end{align*}
\end{tiny}
\end{frame}

%%%%%%%%%%%%%%%%
\section{$\uppi$ expressions}
%%%%%%%%%%%%%%%%

% ---

\begin{frame}{Excerpt of  {\color{red}$\uppi$ lib} expressions}

\begin{grammar}
<Statement>  ::=  <Exp> 

<Exp>        ::=  <ArithExp> | <BoolExp> 

<ArithExp>  ::=  `Num'(<digits>) | `Sum'(<Exp> , <Exp> ) |  `Sub'(<Exp>, <Exp>) | `Mul'(<Exp>, <Exp>) 

<BoolExp>  ::=  `Eq'(<Exp>, <Exp>) | `Not'(<Exp>)
\end{grammar}

\end{frame}

% ---

\begin{frame}{{\color{red}$\uppi$ automata} semantics for {\color{red}$\uppi$ lib} expressions}
\begin{itemize}
\item Recall that $\delta : L(G)^* \times L(G)^* \times Store \to Q$, and let $N, N_i \in \mathbbm{N}$, $C, V \in L(G)^*$, $S \in \mathit{Store}$,
\begin{scriptsize}
\begin{align}
\delta(Num(N) :: C, V, S) & = \delta(C, Num(N) :: V, S) \\
\delta(Sum(E_1, E_2) :: C, V, S) & = \delta(E_1 :: E_2 :: \#SUM :: C, V, S) \\
\delta(\#SUM :: C, Num(N_1) :: Num(N_2) :: V, S) & = \delta(C, Num(N_1 + N_2) :: V, S) \\
\ldots \nonumber \\
\delta(Not(E) :: C, V, S) & = \delta(E :: \#NOT :: C, V, S) \\
\delta(\#NOT :: C, Boo(true) :: V, S) & = \delta(C, Boo(false) :: V, S) \\
\delta(\#NOT :: C, Boo(false) :: V, S) & = \delta(C, Boo(true) :: V, S) 
\end{align}
\end{scriptsize}

\item Notation $h :: ls$ denotes the concatenation of element $h$ with the list $ls$. 

\item $C$ represents the \emph{control} stack. $V$ represents the \emph{value} stack. $S$ denotes the memory store.

\item $\delta(\emptyset, V, S)$ denotes an \emph{accepting state}.
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%
\section{$\uppi$ commands}
%%%%%%%%%%%%%%%

% ---

\begin{frame}{{\color{red} $\uppi$ lib} commands}

\begin{itemize}
\item Commands are language constructions that require both an \emph{environment} and a \emph{memory} store to be evaluated. 
\begin{grammar}
<Statement> ::=  <Cmd> 

<Exp>       ::= `Id'(<String>) 

<Cmd>       ::=  `Assign'(<Id>, <Exp>) \alt `Loop'(<BoolExp>, <Cmd>) \alt  `CSeq'(<Cmd>, <Cmd>)
\end{grammar}


\item From a syntactic standpoint, they extend both statements and expressions, as an identifier is an expression.
\end{itemize}

\end{frame}

% ---

\begin{frame}[allowframebreaks,fragile]{{\color{red}$\uppi$ automata} semantics for {\color{red}$\uppi$ lib} commands}
\begin{itemize}
\item A location $l \in Loc$ denotes a memory cell.
\item Storable and Bindable sets denote the data that may be mapped to by identifiers and locations on the memory and environment respectively. 
\item $Store = Id \mapsto Storable$, $Env = Loc \mapsto Bindable$, $Loc \subseteq Store$, $\mathbbm{N} \subseteq Loc, Bindable$.
\item Now the transition function is $\delta : L(G)^* \times L(G)^* \times Env \times Store \to Q$, and let $W \in String$,  $C, V \in L(G)^*$, $S \in \mathit{Store}$, $E \in Env$, $B \in \mathit{Bindable}$, $l \in Loc$, $T \in \mathit{Storable}$, $X \in <Exp>$, $M, M_1, M_2 \in <Cmd>$,and expression $S' = S/[l \mapsto N]$ means that $S'$ equals to $S$ in all indices but $I$ that is bound to $N$,
\begin{tiny}
\begin{align}
\delta(Id(W) :: C, V, E, S) & = \delta(C, B :: V, E, S), \\ & \text{where}~ E[W] = l ~\text{and}~ S[l] = B,\nonumber \\
%
\delta(Assign(W, X) :: C, V, E, S) & =  \delta(X :: \#ASSIGN :: C, W :: V, E, S'), \\
\delta(\#ASSIGN :: C, T :: W :: V, E, S) & = \delta(C, V, E, S'), & \\ & \text{where}~ E[W] = l ~\text{and}~ S' = S/[l \mapsto T], \nonumber \\
%
\delta(Loop(X, M) :: C, V, E, S) & =  \delta(X :: \#LOOP :: C, Loop(X, M) :: V, E, S),  \\
\delta(\#LOOP :: C, Boo(true) :: Loop(X, M) :: V, E, S) & = \delta(M :: Loop(X, M) :: C, V, E, S),  \\
\delta(\#LOOP :: C, Boo(false) :: Loop(X, M) :: V, E, S) & = \delta(C, V, E, S), \\
%
\delta(CSeq(M_1, M_2) :: C, V, E, S) & = \delta(M_1 :: M_2 :: C, V, E, S).
\end{align}
\end{tiny}
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%
\section{$\uppi$ declarations}
%%%%%%%%%%%%%%%%%%%%%%%%%

% ---

\begin{frame}{{\color{red}$\uppi$ lib} declarations}

\begin{itemize}
\item Declarations are statements that create an environment, binding identifiers to (bindable) values.
\item In {\color{red}$\uppi$ lib}, a bindable value is either a Boolean value, an integer or a location.
\item From a syntactic standpoint, all classes are monotonically extended.
\begin{grammar}
<Statement> ::= <Dec> 

<Exp>       ::= `Ref'(<Exp>)> | `DeRef'(<Id>) | `ValRef'(<Id>)

<Dec>       ::= `Bind'(<Id>, <Exp>) | `DSeq'(<Dec>, <Dec>)

<Cmd>       ::= `Blk'(<Dec>, <Cmd>) 
\end{grammar}
\end{itemize}

\end{frame}

% ---

\begin{frame}[allowframebreaks,fragile]{{\color{red}$\uppi$ automata} semantics for {\color{red}$\uppi$ lib} declarations}

Let $\mathit{BlockLocs} = \mathit{Set}\{\mathit{Loc}\}$, now the transition function is $\delta : L(G)^* \times L(G)^* \times Env \times Store \times \mathit{BlockLocs} \to Q$, and let $L, L' \in \mathit{BlockLocs}$, $\mathit{Loc} \subseteq \mathit{Storable}$,
\begin{tiny}
\begin{align}
% References
\delta(Ref(X) :: C, V, E, S, L) & = \delta(X :: \#REF :: C, V, E, S, L), \\
\delta(\#REF :: C, T :: V, E, S, L) & = \delta(C, l :: V, E, S', L'), \text{ where } S' = S \cup [l \mapsto T], l \not\in S, L' = L \cup \{l\}, \\ \\
% Dereference
\delta(DeRef(Id(W)) :: C, V, E, S, L) & = \delta(C, l :: V, E, S, L), \text{ where } l = E[W],  \\ \\
% Reference value
\delta(ValRef(Id(W)) :: C, V, E, S, L) & = \delta(C, T :: V, E, S, L), \text{ where } T = S[S[E[W]]],  \\ \\
% Bind
\delta(Bind(Id(W), X) :: C, V, E, S, L) &= \delta(X :: \#BIND :: C, W :: V, E, S, L), \\
\delta(\#BIND :: C, B :: W :: E' :: V, E, S, L) &= \delta(C, ([W \mapsto B] \cup E') :: V, E, S, L), \text{ where } E' \in \mathit{Env},\\
\delta(\#BIND :: C, B :: W :: H :: V, E, S, L) &= \delta(C, [W \mapsto B] :: V, E, S, L), \text{ where } H \not\in \mathit{Env},  \\ \\
% DSeq
\delta(DSeq(D_1, D_2), X) :: C, V, E, S, L) &= \delta(D_1 :: D_2 :: C, V, E, S, L), \\ \\
% Block
\delta(Blk(D, M) :: C, V, E, S, L) &= \delta(D :: \#DEC :: M :: \#BLK :: C, L :: V, E, S, \emptyset), \\
\delta(\#DEC :: C, E' :: V, E, S, L) &= \delta(C, E :: V, E / E', S, L), \\
%\delta(\#DEC :: C, m :: V, E, S, L) &= \delta(C, E :: V, E / m, S, L), \text{ where } m \in (\mathit{Id} \mapsto \mathit{Bindable}),\\
\delta(\#BLK :: C, E :: L :: V, E', S, L') &= \delta(C, V, E, S', L), \text{ where } S' = S / L.
\end{align}
where $S / L$ means the store $S$ without the locations in $L$. 
\end{tiny}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%
\section{$\uppi^2$: $\uppi$ Framework in Python}
%%%%%%%%%%%%%%%%%%%%%%%%%

% ---
\begin{frame}[allowframebreaks,fragile]{{\color{red}$\uppi$ lib} expressions in Python}

{\footnotesize\url{https://nbviewer.jupyter.org/github/ChristianoBraga/PiFramework/blob/master/python/pi.ipynb}}

\begin{python}
class Statement: 
    def __init__(self, *args):
        self.opr = args
    def __str__(self):
        ret = str(self.__class__.__name__)+"("
        for o in self.opr:
            ret += str(o)
        ret += ")"
        return ret
class Exp(Statement): pass
class ArithExp(Exp): pass
\end{python}

\framebreak

\begin{python}
class Num(ArithExp): 
    def __init__(self, f): 
        assert(isinstance(f, int))
        ArithExp.__init__(self,f)
class Sum(ArithExp): 
    def __init__(self, e1, e2): 
        assert(isinstance(e1, Exp) and isinstance(e2, Exp))
        ArithExp.__init__(self, e1, e2)
$\ldots$
\end{python}

\framebreak

\begin{python}
class BoolExp(Exp): pass
class Eq(BoolExp):
    def __init__(self, e1, e2):
        assert(isinstance(e1, Exp) and isinstance(e2, Exp))
        BoolExp.__init__(self, e1, e2)
$\ldots$
\end{python}

\framebreak

\begin{python}
exp = Sum(Num(1), Mul(Num(2), Num(4)))
print(exp)

Sum(Num(1)Mul(Num(2)Num(4)))
\end{python}

\framebreak

\begin{python}
exp2 = Mul(2, 1)
---------------------------------------------------------------------------
AssertionError                            Traceback (most recent call last)
<ipython-input-7-00fd40a79a54> in <module>()
----> 1 exp2 = Mul(2, 1)

<ipython-input-5-42a82e58862f> in __init__(self, e1, e2)
     28 class Mul(ArithExp):
     29     def __init__(self, e1, e2):
---> 30         assert(isinstance(e1, Exp) and isinstance(e2, Exp))
     31         ArithExp.__init__(self, e1, e2)
     32 class BoolExp(Exp): pass

AssertionError: 
\end{python}
\end{frame}

% ---

\begin{frame}[allowframebreaks,fragile]{{\color{red}$\uppi$ automaton} for {\color{red}$\uppi$ lib} expressions}

\begin{python}
## Expressions
class ValueStack(list): pass
class ControlStack(list): pass
class ExpKW:
    SUM = "#SUM"
    SUB = "#SUB"
    MUL = "#MUL"
    EQ = "#EQ"
    NOT = "#NOT"
\end{python}

\framebreak    

\begin{python}    
class ExpPiAut(dict):
    def __init__(self):    
        self["val"] = ValueStack()
        self["cnt"] = ControlStack()
    def __evalSum(self, e):
        e1 = e.opr[0]
        e2 = e.opr[1]
        self.pushCnt(ExpKW.SUM)
        self.pushCnt(e1)
        self.pushCnt(e2)
    def pushCnt(self, e):
        cnt = self.cnt()
        cnt.append(e)
$\ldots$
\end{python}

\framebreak

\begin{python}    
ea = ExpPiAut()
print(exp)
ea.pushCnt(exp)
while not ea.emptyCnt():
    ea.eval()
    print(ea)
\end{python}

\framebreak

\begin{adjustbox}{width=2\textwidth}
\begin{python}    
Sum(Num(1)Mul(Num(2)Num(4)))
{'val': [], 'cnt': ['#SUM', <__main__.Num object at 0x111851470>, <__main__.Mul object at 0x1118516d8>]}
{'val': [], 'cnt': ['#SUM', <__main__.Num object at 0x111851470>, '#MUL', <__main__.Num object at 0x111851630>, <__main__.Num object at 0x1118516a0>]}
{'val': [4], 'cnt': ['#SUM', <__main__.Num object at 0x111851470>, '#MUL', <__main__.Num object at 0x111851630>]}
{'val': [4, 2], 'cnt': ['#SUM', <__main__.Num object at 0x111851470>, '#MUL']}
{'val': [8], 'cnt': ['#SUM', <__main__.Num object at 0x111851470>]}
{'val': [8, 1], 'cnt': ['#SUM']}
{'val': [9], 'cnt': []}
\end{python}
\end{adjustbox}

\end{frame}

% ---

\begin{frame}[allowframebreaks,fragile]{{\color{red}$\uppi$ lib} commands}

\begin{adjustbox}{width=0.8\textwidth}
\begin{python}
class Cmd(Statement): pass
class Id(Exp):
    def __init__(self, s):
        assert(isinstance(s, str))
        Exp.__init__(self, s)
class Assign(Cmd):
    def __init__(self, i, e): 
        assert(isinstance(i, Id) and isinstance(e, Exp))
        Cmd.__init__(self, i, e)
class Loop(Cmd):
    def __init__(self, be, c):
        assert(isinstance(be, BoolExp) and isinstance(c, Cmd))
        Cmd.__init__(self, be, c)
class CSeq(Cmd):
    def __init__(self, c1, c2):
        assert(isinstance(c1, Cmd) and isinstance(c2, Cmd))
        Cmd.__init__(self, c1, c2)
\end{python}
\end{adjustbox}

\framebreak
        
\begin{python}
cmd = Assign(Id("x"), Num(1))
print(type(cmd))
print(cmd)
<class '__main__.Assign'>
Assign(Id(x)Num(1))
\end{python}
\end{frame}

% ---

\begin{frame}[allowframebreaks,fragile]{{\color{red}$\uppi$ automaton} for {\color{red}$\uppi$ lib} commands}

Environment, Location, Store and commands opcodes.

\begin{python}
## Commands
class Env(dict): pass
class Loc(int): pass
class Sto(dict): pass
class CmdKW:
    ASSIGN = "#ASSIGN"
    LOOP = "#LOOP"
\end{python}

\framebreak

{\color{red}$\uppi$ automaton} for commands extends the {\color{red}$\uppi$ automaton}  for expressions.

\begin{python}    
class CmdPiAut(ExpPiAut): 
    def __init__(self):    
        self["env"] = Env()
        self["sto"] = Sto()
        ExpPiAut.__init__(self)
    def env(self):
        return self["env"]
    def getLoc(self, i):
        en = self.env()
        return en[i]
    def sto(self):
        return self["sto"]
    def updateStore(self, l, v):
        st = self.sto()
        st[l] = v
\end{python}

\framebreak
        
{\color{red}$\uppi$}  semantics for assignment.

\begin{scriptsize}
\begin{align}
\delta(Assign(W, X) :: C, V, E, S) & = \delta(X :: \#ASSIGN :: C, W :: V, E, S'), \nonumber \\
\delta(\#ASSIGN :: C, T :: W :: V, E, S) & = \delta(C, V, E, S'), & \nonumber \\ & \text{where}~ E[W] = l ~\text{and}~ S' = S/[l \mapsto T]. \nonumber
\end{align}
\end{scriptsize}

\begin{python}
    def __evalAssign(self, c): 
        i = c.opr[0]
        e = c.opr[1]
        self.pushVal(i.opr[0])
        self.pushCnt(CmdKW.ASSIGN)
        self.pushCnt(e)
    def __evalAssignKW(self):
        v = self.popVal()
        i = self.popVal()
        l = self.getLoc(i)
        self.updateStore(l, v) 
\end{python}

\framebreak

{\color{red}$\uppi$}  semantics for identifiers.
        
\begin{scriptsize}
\begin{align}
\delta(Id(W) :: C, V, E, S) & = \delta(C, B :: V, E, S), \nonumber \\ & \text{where}~ E[W] = l ~\text{and}~ S[l] = B. \nonumber 
\end{align}
\end{scriptsize}
        
\begin{python}
    def __evalId(self, i):
        s = self.sto()
        l = self.getLoc(i)
        self.pushVal(s[l])
\end{python}

\framebreak
       
{\color{red}$\uppi$}  semantics for loop: recursive step.

\begin{scriptsize}
\begin{align}
\delta(Loop(X, M) :: C, V, E, S) & = \delta(X :: \#LOOP :: C, Loop(X, M) :: V, E, S). \nonumber 
\end{align}
\end{scriptsize}
       
\begin{python}
    def __evalLoop(self, c):
        be = c.opr[0]
        bl = c.opr[1]
        self.pushVal(Loop(be, bl))
        self.pushVal(bl)
        self.pushCnt(CmdKW.LOOP)
        self.pushCnt(be)
\end{python}

\framebreak
       
{\color{red}$\uppi$}  semantics for loop: basic steps.

\begin{scriptsize}
\begin{align}
\delta(\#LOOP :: C, Boo(true) :: Loop(X, M) :: V, E, S) & = \delta(M :: Loop(X, M) :: C, V, E, S), \nonumber \\
\delta(\#LOOP :: C, Boo(false) :: Loop(X, M) :: V, E, S) & = \delta(C, V, E, S). \nonumber
\end{align}
\end{scriptsize}
       
\begin{python}
    def __evalLoopKW(self):
        t = self.popVal()
        if t:
            c = self.popVal()
            lo = self.popVal()
            self.pushCnt(lo)
            self.pushCnt(c)
        else:
            self.popVal()
            self.popVal()
\end{python}

\framebreak

{\color{red}$\uppi$}  semantics for command composition.

\begin{scriptsize}
\begin{align}
\delta(CSeq(M_1, M_2) :: C, V, E, S) & = \delta(M_1 :: M_2 :: C, V, E, S). \nonumber
\end{align}
\end{scriptsize}

\begin{python}
    def __evalCSeq(self, c):
        c1 = c.opr[0]
        c2 = c.opr[1]
        self.pushCnt(c2)
        self.pushCnt(c1)
\end{python}

\framebreak

Commands are now on the top of the food chain.

\begin{python}
    def eval(self): 
        c = self.popCnt()
        if isinstance(c, Assign):
            self.__evalAssign(c)
        elif c == CmdKW.ASSIGN:
            self.__evalAssignKW()
        elif isinstance(c, Id):
            self.__evalId(c.opr[0])
        elif isinstance(c, Loop):
            self.__evalLoop(c)
        elif c == CmdKW.LOOP:
            self.__evalLoopKW()
        elif isinstance(c, CSeq):
            self.__evalCSeq(c)
        else:
            self.pushCnt(c)
            ExpPiAut.eval(self)
\end{python}
\end{frame}

% ---

\subsection{Declarations}
\begin{frame}[allowframebreaks,fragile]{{\color{red}$\uppi$ lib} declarations in Python}

\flushright{\fbox{\texttt{Deref} not implemented yet.}}

\begin{python}
## Declarations
class Dec(Statement): pass
class Bind(Dec):
   def __init__(self, i, e):
       assert (isinstance(i, Id) and isinstance(e, Exp))
       Dec.__init__(self, i, e)
class Ref(Exp):
   def __init__(self, e):
       assert (isinstance(e, Exp))
       Exp.__init__(self, e)
class Cns(Exp):
   def __init__(self, e):
       assert (isinstance(e, Exp))
       Exp.__init__(self, e)       
class Blk(Cmd):
   def __init__(self, d, c):
       assert (isinstance(d, Dec) and isinstance(c, Cmd))
       Cmd.__init__(self, d, c)
\end{python}
\framebreak
\begin{python}
class DSeq(Dec):
   def __init__(self, d1, d2):
       assert (isinstance(d1, Dec) and isinstance(d2, Dec))
       Dec.__init__(self, d1, d2)
\end{python}

\framebreak

\begin{python}
## Declarations
class DecExpKW(ExpKW):
   REF = "#REF"
   CNS = "#CNS"

class DecCmdKW(CmdKW):
   BLKDEC = "#BLKDEC"
   BLKCMD = "#BLKCMD"

class DecKW:
   BIND = "#BIND"
   DSEQ = "#DSEQ"

class DecPiAut(CmdPiAut):
   def __init__(self):
       self["locs"] = []
       CmdPiAut.__init__(self)

   def locs(self):
       return self["locs"]

   def pushLoc(self, l):
       ls = self.locs()
       ls.append(l)

   def __evalRef(self, e):
       ex = e.opr[0]
       self.pushCnt(DecExpKW.REF)
       self.pushCnt(ex)

   def __newLoc(self):
       sto = self.sto()
       if sto:
           return max(list(sto.keys())) + 1
       else:
           return 0.0

   def __evalRefKW(self):
       v = self.popVal()
       l = self.__newLoc()
       self.updateStore(l, v)
       self.pushLoc(l)
       self.pushVal(l)

   def __evalBind(self, d):
       i = d.opr[0]
       e = d.opr[1]
       self.pushVal(i)
       self.pushCnt(DecKW.BIND)
       self.pushCnt(e)

   def __evalBindKW(self):
       l = self.popVal()
       i = self.popVal()
       x = i.opr[0]
       self.pushVal({x: l})

   def __evalDSeq(self, ds):
       d1 = ds.opr[0]
       d2 = ds.opr[1]
       self.pushCnt(DecKW.DSEQ)
       self.pushCnt(d2)
       self.pushCnt(d1)

   def __evalDSeqKW(self):
       d2 = self.popVal()
       d1 = self.popVal()
       d1.update(d2)
       self.pushVal(d1)

   def __evalBlk(self, d):
       ld = d.opr[0]
       c = d.opr[1]
       l = self.locs()
       self.pushVal(list(l))
       self.pushVal(c)
       self.pushCnt(DecCmdKW.BLKDEC)
       self.pushCnt(ld)

   def __evalBlkDecKW(self):
       d = self.popVal()
       c = self.popVal()
       l = self.locs()
       self.pushVal(l)
       en = self.env()
       ne = en.copy()
       ne.update(d)
       self.pushVal(en)
       self["env"] = ne
       self.pushCnt(DecCmdKW.BLKCMD)
       self.pushCnt(c)

   def __evalBlkCmdKW(self):
       en = self.popVal()
       ls = self.popVal()
       self["env"] = en
       s = self.sto()
       s = {k: v for k, v in s.items() if k not in ls}
       self["sto"] = s
       # del ls
       ols = self.popVal()
       self["locs"] = ols

   def eval(self):
       d = self.popCnt()
       if isinstance(d, Bind):
           self.__evalBind(d)
       elif d == DecKW.BIND:
           self.__evalBindKW()
       elif isinstance(d, DSeq):
           self.__evalDSeq(d)
       elif d == DecKW.DSEQ:
           self.__evalDSeqKW()
       elif isinstance(d, Ref):
           self.__evalRef(d)
       elif d == DecExpKW.REF:
           self.__evalRefKW()
       elif isinstance(d, Blk):
           self.__evalBlk(d)
       elif d == DecCmdKW.BLKDEC:
           self.__evalBlkDecKW()
       elif d == DecCmdKW.BLKCMD:
           self.__evalBlkCmdKW()
       else:
           self.pushCnt(d)
           CmdPiAut.eval(self)
\end{python}

\framebreak

\begin{python}
dc = DecPiAut()
fac = Loop(Not(Eq(Id("y"), Num(0))),
          CSeq(Assign(Id("x"), Mul(Id("x"), Id("y"))),
               Assign(Id("y"), Sub(Id("y"), Num(1)))))
dec = DSeq(Bind(Id("x"), Ref(Num(1))),
          Bind(Id("y"), Ref(Num(200))))
fac_blk = Blk(dec, fac)
dc.pushCnt(fac_blk)
while not dc.emptyCnt():
   aux = dc.copy()
   dc.eval()
   if dc.emptyCnt():
       print(aux)
\end{python}

\end{frame}


% ---

\section{\textsc{IMP} language}

% ---

\begin{frame}[fragile]{\textsc{IMP} \emph{concrete syntax} for expressions and commands}

\begin{grammar}
<prog> ::= <cmd>* 

<cmd> ::= `while' `('<bexp>`)' `do' `{' <cmd> `}'  \alt <id> `:=' <exp> | <cmd> `;' <cmd> 

<exp> ::= <aexp> | <bexp> 

<aexp> ::= <aexp> `+' <term> | <aexp> `-' <term> | <term>

<term> ::= <term> `*' <factor> | <term> `/' <factor> | <factor>

<factor> ::= `(' <aexp> `)'  | <digits> | <id>

<bexp> ::= <id> | <boolean> | `~' <bexp> | <bexp> <boolop> <bexp> 
\alt <aexp> <iop> <aexp>

<boolop> ::= `=' | `/\BS' | `\BS/'

<iop> ::= `<' | `>' | `<=' | `>=' 
\end{grammar}

\end{frame}

% ---

\begin{frame}[fragile]{Example: iterative factorial}
\begin{lstlisting}
while (~ (x = 0))
do {
     y := y * x ;
     x := x - 1
} ;
y
\end{lstlisting}
\end{frame}

% ---


\end{document}

