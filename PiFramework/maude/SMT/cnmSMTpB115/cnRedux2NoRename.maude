fmod CNMSMTPB is
  protecting NAT .
  protecting SMTLOGIC .
  protecting CONVERSION .
  protecting AX-COHERENCE-COMPLETION .

  sorts SmtRule Params IntSmtRule KindIntSmtRule KindIntSmtRuleSetInt KindIntSmtRuleSet FullCondi State SubsPairInt Solution
        RuleCondi OrigPr OrigPrCond BoolKind TeTeInt TListTeInt ReachProblem ReachGoal Problem NatProblem NatPrList ProblemSet .
  
  subsort KindIntSmtRule < KindIntSmtRuleSet .
  subsort ReachProblem < ReachGoal .
  subsort Solution < NatProblem < NatPrList .
  subsort Problem < ProblemSet .
  
  vars STEPS ANSWERS DEPTH DEPTH' : Nat .
  vars I RN NV NV' NV'' NVR NA : Int .
  vars Q SQ F F' : Qid .
  vars SPS RVS VS QS QS' : QidSet .       *** smt parameters set, rule variables set (different for each rule)
  vars V V' : Variable .
  vars C C' : Constant .
  vars L L0 R R' R0 T TC TC' : Term .
  vars TL TL' OVL OVL' : TermList .
  var NETL : NeTermList .
  var CO : Condition .
  var RC RC' : RuleCondi .
  vars SC SC1 SC' : SmtCondi .
  vars ST ST' : SmtTerm .
  vars SAT SAT' : SmtATerm .
  vars GSC GSC' : GroundSmtCondi .
  vars GST GST' : GroundSmtTerm .
  vars K K' K'' : Kind .
  var TY : Type .
  vars M SM : Module .
  var IL : ImportList .
  var SS : SortSet .
  var SSDS : SubsortDeclSet .
  var OPD : OpDecl .
  var OPDS : OpDeclSet .
  var MAS : MembAxSet .
  var EQS : EquationSet .
  var RL : Rule .
  var SRL : SmtRule .
  var KISRL : KindIntSmtRule .
  var RLS : RuleSet .
  vars KISRLS KISRLS' : KindIntSmtRuleSet .
  var AtS : AttrSet .
  vars SU SU' AN AN' : Substitution .
  var AS : Assignment .
  var SPI : SubsPairInt .
  var BO : Boolean .
  var RP : ReachProblem .
  var PR : Problem .
  var SOL : Solution .
  vars NP NP' : NatProblem .
  vars NP0 NPL1 NPL2 NPL NPL' : NatPrList .
  var PS : ProblemSet .
  var OP : OrigPr .
  var OPC : OrigPrCond .
  
************* TARGET MODULE *******************

  op target : -> Qid .
  eq target = 'TOASTS .
***  eq target = 'VENDING-MACHINE .
  
************* MEMOIZED CONSTANTS *******************

  op moduleNoRls : -> Module [memo] .
  op removeRls : Module -> Module .

  eq moduleNoRls
   = removeRls(upModule(target, false)) .
  eq removeRls(mod Q is IL sorts SS . SSDS OPDS MAS EQS RLS endm)
   = mod Q is IL sorts SS . SSDS OPDS MAS EQS none endm .  
    
  op congruenceKinds1 : -> QidSet [memo] .   *** kinds whose terms may get the congruence rule applied .
  op congruenceKinds2 : -> QidSet [memo] .   *** kinds for subterms where congruence can be applied
  eq congruenceKinds1 = getKind(moduleNoRls, 'System) .
  eq congruenceKinds2 = getKind(moduleNoRls, 'Kitchen) .
***  eq congruenceKinds1 = getKind(moduleNoRls, 'State2) .
***  eq congruenceKinds2 = getKind(moduleNoRls, 'Cash) .
***  eq congruenceKinds1 = none .
***  eq congruenceKinds2 = none .
    
  op smtParams : -> QidSet [memo] .
  op getSmtParams : OpDeclSet QidSet -> QidSet .
  
  eq smtParams = getSmtParams(getOps(moduleNoRls), none) .
  eq getSmtParams(none, SPS) = SPS .
  eq getSmtParams(op Q :  nil -> TY [AtS] . OPDS, SPS)
   = if TY in smtSorts
     then getSmtParams(OPDS, qid(string(Q) + "." + string(TY)) ; SPS)
     else getSmtParams(OPDS, SPS) fi .
  eq getSmtParams(OPD OPDS, SPS)
   = getSmtParams(OPDS, SPS) [owise] .

  op smtVParams : -> QidSet [memo] .
  op getSmtVParams : OpDeclSet QidSet -> QidSet .

  eq smtVParams = getSmtVParams(getOps(moduleNoRls), none) .
  eq getSmtVParams(none, SPS) = SPS .
  eq getSmtVParams(op Q :  nil -> TY [AtS] . OPDS, SPS)
   = if TY in smtSorts
     then getSmtVParams(OPDS, qid(string(Q) + ":" + string(TY)) ; SPS)
     else getSmtVParams(OPDS, SPS) fi .
  eq getSmtVParams(OPD OPDS, SPS)
   = getSmtVParams(OPDS, SPS) [owise] .

  op normalRls : -> KindIntSmtRuleSet [memo] .
  op normalRlsKind : Kind -> KindIntSmtRuleSet [memo] .
  op normalRlsKind* : KindIntSmtRuleSet Kind -> KindIntSmtRuleSet .
  op normalRlsInt : -> KindIntSmtRuleSetInt .
  op normalRlsNV : -> Int .
  op transformRls : RuleSet Int -> KindIntSmtRuleSet .
  op transformRl : Rule Int -> KindIntSmtRule .
  op rc2Src : Condition -> RuleCondi .
  op normalizeRls : KindIntSmtRuleSet KindIntSmtRuleSet Int -> KindIntSmtRuleSetInt .
  op normalizeRlsReorder : KindIntSmtRuleSet KindIntSmtRuleSetInt KindIntSmtRuleSet Int -> KindIntSmtRuleSetInt .
  op normalizeRl : KindIntSmtRule Int -> KindIntSmtRuleSetInt .
  op normalizeRl* : Kind Int TeTeInt Term RuleCondi -> KindIntSmtRuleSetInt .
  op getKISRLS : KindIntSmtRuleSetInt -> KindIntSmtRuleSet .
  op getNV : KindIntSmtRuleSetInt -> Int .
  

  eq normalRlsKind(K)
   = normalRlsKind*(normalRls, K) .
  eq normalRlsKind*((K / RN / SRL) KISRLS, K)
   = (K / RN / SRL) normalRlsKind*(KISRLS, K) .
  eq normalRlsKind*(KISRLS, K)
   = kNone [owise] .
   
  eq getKISRLS(KISRLS ; NV) = KISRLS .
  eq getNV(KISRLS ; NV) = NV .
  eq normalRls = getKISRLS(normalRlsInt) .
  eq normalRlsNV = getNV(normalRlsInt) .
  eq normalRlsInt = normalizeRls(kNone, transformRls(getRls(axCohComplete(upModule(target, false))), 1), 0) .
  eq transformRls(none, RN) =  kNone .
  eq transformRls(RL RLS, RN) = transformRl(RL, RN) transformRls(RLS, s(RN)) [owise] .
  eq transformRl(rl L => R [AtS] ., RN) =
      (getKind(moduleNoRls, leastSort(moduleNoRls, L)) / RN / L => R if nilR && 'true.Boolean) .
  eq transformRl(crl L => R if (TC = 'true.Boolean) [AtS] ., RN) =
      (getKind(moduleNoRls, leastSort(moduleNoRls, L)) / RN / L => R if nilR && TC)  .
  eq transformRl(crl L => R if CO /\ (TC = 'true.Boolean) [AtS] ., RN) =
      (getKind(moduleNoRls, leastSort(moduleNoRls, L)) / RN / L => R if rc2Src(CO) && TC) .
  eq transformRl(crl L => R if CO [AtS] ., RN) =
      (getKind(moduleNoRls, leastSort(moduleNoRls, L)) / RN / L => R if rc2Src(CO) && 'true.Boolean) .
	  
  eq rc2Src(nil) = nilR .
  eq rc2Src(L => R /\ CO) = getKind(moduleNoRls, leastSort(moduleNoRls,L)) / L =>* R & rc2Src(CO) .

  eq normalizeRls(KISRLS, kNone, NV) 
   =  KISRLS ; NV .
  eq normalizeRls(KISRLS, KISRL KISRLS', NV) 
   = normalizeRlsReorder(KISRLS, normalizeRl(KISRL, 0), KISRLS', NV) [owise] .
  eq normalizeRl(K / RN / L => R if RC && TC, NV) 
   = normalizeRl*(K, RN, normalizeTerm(L, TC, NV, leastSort(moduleNoRls, L)), R, RC) .
  eq normalizeRl*(K, RN, (L / TC ; NV), R, RC) 
   = K / RN / L => R if RC && TC ; NV .
  eq normalizeRlsReorder(KISRLS, KISRL ; NV', KISRLS', NV)
   = if NV' < NV
     then normalizeRls(KISRLS KISRL, KISRLS', NV)
     else normalizeRls(KISRLS KISRL, KISRLS', NV') fi .
  
  op normalizeTerm : Term Term Int Type -> TeTeInt .
  op normalizeTerm* : Term Variable Term Int -> TeTeInt .
  op joinTermList : Qid TListTeInt -> TeTeInt .
  op normalizeTermList  : TermList TermList Term Int -> TListTeInt .
  op normalizeTermList* : TermList TermList TeTeInt -> TListTeInt .
 
  eq normalizeTerm(C, TC, NV, TY)
   = if TY in smtSorts
     then normalizeTerm*(constants2variables(C, smtParams), newVar(NV, TY), TC, s(NV))
     else C / TC ; NV fi .
  eq normalizeTerm(V, TC, NV, TY) = V / TC ; NV .
  eq normalizeTerm(F[TL], TC, NV, TY)
   = if TY in smtSorts
     then normalizeTerm*(constants2variables(F[TL], smtParams), newVar(NV, TY), TC, s(NV))
	 else joinTermList(F, normalizeTermList(TL, empty, TC, NV)) fi .
  eq normalizeTerm*(T, V, TC, NV)
   = V / '_and_[TC,'_===_[V,T]] ; NV .
  eq joinTermList(F, (TL ; TC ; NV)) = F[TL] / TC ; NV .
  eq normalizeTermList(empty, TL, TC, NV) = TL ; TC ; NV .
  eq normalizeTermList((T, TL), TL', TC, NV) 
   = normalizeTermList*(TL, TL', normalizeTerm(T, TC, NV, leastSort(moduleNoRls, T))) [owise] .
  eq normalizeTermList*(TL, TL', (T / TC ; NV)) 
   = normalizeTermList(TL, (TL', T), TC, NV) .

  op getRule : Int KindIntSmtRuleSet -> SmtRule [memo] .
  eq getRule(RN, K / RN / SRL KISRLS)
   = SRL  .

  op getRuleVars : Int -> QidSet [memo] .
  ceq getRuleVars(RN)
   = getVarSet(L0) ; getVarSet(R) ; getVarSetRc(RC) ; getVarSet(TC)
     if L0 => R if RC && TC := getRule(RN, normalRls) .

  op _-_ : Bool Kind -> BoolKind .
  op noBoolKind : -> BoolKind .
  op existsRule : Constant -> BoolKind [memo] .
  ceq existsRule(C) = true - K if (K / RN / C => R if RC && TC) KISRLS := normalRls .
  eq existsRule(C) = noBoolKind [owise] .


************* CONSTRUCTORS *******************

  op _;_ : Int SmtRule -> IntSmtRule [ctor prec 79] .               *** Int is the number of the next fresh variable .
  op kNone : -> KindIntSmtRuleSet [ctor] .
  op _/_/_ : Kind Int SmtRule -> KindIntSmtRule [ctor prec 79] . *** Int is the number of the rule
  op __ : KindIntSmtRuleSet KindIntSmtRuleSet -> KindIntSmtRuleSet [ctor assoc comm id: kNone prec 81 format (d ni d)] .
  op _;_ : KindIntSmtRuleSet Int -> KindIntSmtRuleSetInt [ctor prec 83] .   *** Int is the number of the next fresh variable .

  op nilOP : -> OrigPr [ctor] .
  op _=>*_ : Term Term -> OrigPr [ctor prec 71] .
  op _&_ : OrigPr OrigPr -> OrigPr [ctor assoc id: nilOP prec 73] .
  op _&&_ : OrigPr Term -> OrigPrCond [ctor prec 75] .

  op nilR : -> RuleCondi [ctor] .
  op errorR : -> RuleCondi [ctor] .
  op _/_=>*_ : Kind Term Term -> RuleCondi [ctor prec 71] .
  op _/_/_=>0_ : Int Substitution Term Term -> RuleCondi [ctor prec 71] .
  op _&_ : RuleCondi RuleCondi -> RuleCondi [ctor assoc id: nilR prec 73] .
  op _&&_ : RuleCondi Term -> FullCondi [ctor prec 75] .
  op _=>_if_ : Term Term FullCondi -> SmtRule [ctor format (d d d d d s) prec 77] .
  op _||_ : RuleCondi SmtCondi -> ReachProblem [ctor prec 75] .
  op _/_=>1_&_||_ : Kind Term Variable RuleCondi SmtCondi -> ReachGoal [ctor prec 77] .
  op _/_,_,_,_/_/_=>1_&_||_ : Int Int Term Term RuleCondi Substitution Term Variable RuleCondi SmtCondi -> ReachGoal [ctor prec 77] .
  op nilP : -> Problem [ctor] .
  op _;_;_;_ : ReachGoal TermList Int Substitution -> Problem [ctor prec 79] .

  op _/_;_ : Term Term Int -> TeTeInt [ctor] .
  op _;_;_ : TermList Term Int -> TListTeInt [ctor] .
  op _,_,_ : Substitution Substitution Int -> SubsPairInt [ctor] .
  op _|_ : Substitution SmtCondi -> Problem [ctor prec 79] .
  op nilNP : -> NatProblem [ctor] .
  op _|_ : Nat Problem -> NatProblem [ctor prec 81] .
  op _||_ : NatPrList NatPrList -> NatPrList [ctor assoc id: nilNP prec 83] .
  op __ : ProblemSet ProblemSet -> ProblemSet [ctor assoc comm id: nilP prec 81] .
  op _/_/_/_/_ : Nat Nat NatPrList NatPrList ProblemSet -> State [ctor] .
  op <_,_,_> : Nat Nat NatPrList -> State [ctor] .
  
  eq DEPTH | nilP = nilNP .

  mb DEPTH | nilR || SC ; OVL ; NV ; AN : Solution .

************* PROBLEM DEFINITION *******************

  op problem : Nat Nat OrigPrCond -> State .
  op processState   : Nat Nat            NatPrList NatPrList NatPrList ProblemSet -> State .
  op processState*  : Nat Nat NatProblem NatPrList NatPrList NatPrList ProblemSet -> State .
  op processState** : Nat Nat NatProblem NatPrList NatPrList NatPrList ProblemSet -> State .
  op processSol : Nat Nat NatProblem NatPrList NatPrList NatPrList ProblemSet -> State .
  op processNatPr : NatProblem -> NatPrList .
  op op2Rc : OrigPr RuleCondi -> RuleCondi .
  op isNewSolution : Problem NatPrList -> Bool .
  
  eq problem(ANSWERS, DEPTH, (OP && TC))
   = 1 / ANSWERS / (DEPTH | (op2Rc(OP, nilR) || term2cExpr(TC) ; getVarListOpc(OP && TC) ; normalRlsNV ; none)) / nilNP / nilP .
   
  eq STEPS / ANSWERS / nilNP / NPL' / PS
   = < STEPS, ANSWERS, NPL' > .
  eq STEPS / 0 / NPL / NPL' / PS
   = < STEPS, 0, NPL' > .
  eq STEPS / ANSWERS / DEPTH | PR || NPL / NPL' / PS
   = processState(STEPS, ANSWERS, processNatPr(DEPTH | PR), NPL, NPL', PS) [owise] .
   
  eq processState(STEPS, ANSWERS, nilNP, NPL, NPL', PS)                   *** remove existing states
   = STEPS / ANSWERS / NPL / NPL' / PS .
  eq processState(STEPS, ANSWERS, DEPTH | PR || NP0, NPL, NPL', PR PS)
   = processState(STEPS, ANSWERS, NP0, NPL, NPL', PR PS) .
  eq processState(STEPS, ANSWERS, DEPTH | PR || NP0, NPL1 || DEPTH' | PR || NPL2, NPL', PS)
   = processState(STEPS, ANSWERS, NP0, NPL1 || DEPTH' | PR || NPL2, NPL', PS) .
  eq processState(STEPS, ANSWERS, DEPTH | PR || NP0, NPL, NPL', PS)
   = processState*(STEPS, ANSWERS, DEPTH | PR, NP0, NPL, NPL', PS) [owise] .
   
  eq processState*(STEPS, ANSWERS, (DEPTH | nilR || SC ; OVL ; NV ; AN), NP0, NPL, NPL', PS)   *** if new solution add it to the list
   = processSol(STEPS, ANSWERS, (DEPTH | nilR || smtSimplify(SC) ; OVL ; NV ; simplifyAnswer(AN)), NP0, NPL, NPL', PS) .
						   
  eq processState*(STEPS, ANSWERS, NP, NP0, NPL, NPL', PS)               *** no new solution, process the problem
   = processState**(s(STEPS), ANSWERS, NP, NP0, NPL, NPL', PS) [owise] .

  eq processState**(STEPS, ANSWERS, 0 | PR, NP0, NPL, NPL', PS)                            *** can't go any deeper, forget the problem
   = processState(STEPS, ANSWERS, NP0, NPL, NPL', PS) .                  
  eq processState**(STEPS, ANSWERS, s(DEPTH) | (K / L =>* R & RC || SC ; OVL ; NV ; AN), NP0, NPL, NPL', PS) *** narrowing or unif step
   = processState(STEPS, ANSWERS, NP0, NPL || s(DEPTH) | (K / L =>* R & RC || SC ; OVL ; NV ; AN),           *** add to the list
                  NPL', (K / L =>* R & RC || SC ; OVL ; NV ; AN) PS) .                                       *** and to the set
  eq processState**(STEPS, ANSWERS, NP, NP0, NPL, NPL', PS)
   = processState(STEPS, ANSWERS, NP0, NPL || NP, NPL', PS) [owise] .                                        *** else add to the list only
   
   eq processSol(STEPS, s(ANSWERS), DEPTH | PR, NP0, NPL, NPL', PS)   *** if new solution add it to the list
   = if isNewSolution(PR, NPL')
        then processState(STEPS, ANSWERS, NP0, NPL, NPL' || DEPTH | PR, PS)
	    else processState(STEPS, s(ANSWERS), NP0, NPL, NPL', PS) fi .

  eq isNewSolution(PR, NPL || DEPTH | PR || NPL') = false .
  eq isNewSolution(PR, NPL') = true [owise] .
   
  eq op2Rc(nilOP, RC)
   = RC .
  eq op2Rc(V =>* R & OP, RC)
   = errorR .
  eq op2Rc(F[TL] =>* R & OP, RC)
   = if leastSort(moduleNoRls, F[TL]) in smtSorts
     then errorR
     else op2Rc(OP, RC & getKind(moduleNoRls, leastSort(moduleNoRls, F[TL])) / F[TL] =>* R) fi .
  eq op2Rc(C =>* R & OP, RC)
   = if getType(C) in smtSorts
     then errorR
     else op2Rc(OP, RC & getType(C) / C =>* R) fi .
  

************* NARROWING *******************

  eq processNatPr(DEPTH | K / L =>* R & RC || SC ; OVL ; NV ; AN)
   = t(DEPTH | K / L =>* R & RC || SC ; OVL ; NV ; AN) ||
     u(DEPTH | K / L =>* R & RC || SC ; OVL ; NV ; AN) .

  op t : NatProblem -> NatProblem .
  eq t(DEPTH | K / L =>* R & RC || SC ; OVL ; NV ; AN)
   = DEPTH | K / L =>1 newVar(NV, K) & K / newVar(NV, K) =>* R & RC || SC ; OVL ; s(NV) ; AN .
  
  op u : NatProblem -> NatProblem .
  ceq u(DEPTH | K / L =>* R & RC || SC ; OVL ; NV ; AN)
   = DEPTH | 1 / SU / L =>0 R0 & RC || SC and term2cExpr(TC) ; OVL ; NV'' ; AN
	 if (R0 / TC ; NV') := abstract(R, NV) /\ {SU, NV''} := metaUnify(moduleNoRls, L =? R0, NV', 0) .
	 
  eq u(NP) = nilNP [owise] .
	
  eq processNatPr(DEPTH | NA / SU / L =>0 R0 & RC || SC ; OVL ; NV ; AN)
   = u1(DEPTH | NA / SU / L =>0 R0 & RC || SC ; OVL ; NV ; AN) ||
     u2(DEPTH | NA / SU / L =>0 R0 & RC || SC ; OVL ; NV ; AN) .

  op u1 : NatProblem -> NatProblem .
  ceq u1(DEPTH | NA / SU / L =>0 R0 & RC || SC ; OVL ; NV ; AN)
   = DEPTH | simplifySatisfSC(
	         RC << SU || 
		     removeGSCs(SC') ; OVL ; NV ; 
		     (AN .. SU) |>* OVL, 'true.Boolean)
	 if SC' := (SC <<* su2smtSu(SU, smtParams)) /\ metaCheck(smtModule, downSmt(SC', false)) .
	 
  eq u1(NP) = nilNP [owise] .
  
  op u2 : NatProblem -> NatProblem .
  ceq u2(DEPTH | NA / SU / L =>0 R0 & RC || SC ; OVL ; NV ; AN)
   = DEPTH | s(NA) / SU' / L =>0 R0 & RC || SC ; OVL ; NV' ; AN
	 if {SU', NV'} := metaUnify(moduleNoRls, L =? R0, NV, NA) .
	 
  eq u2(NP) = nilNP [owise] .

  eq processNatPr(DEPTH | K / T =>1 V & K' / L =>* R & RC || SC ; OVL ; NV ; AN)
   = c(DEPTH | K / T =>1 V & K' / L =>* R & RC || SC ; OVL ; NV ; AN) ||
     n(normalRlsKind(K), DEPTH | K / T =>1 V & K' / L =>* R & RC || SC ; OVL ; NV ; AN) .

  op c : NatProblem -> NatProblem .
  ceq c(DEPTH | K / F[TL, C, TL'] =>1 V & K' / L =>* R & RC || SC ; OVL ; NV ; AN)
   = DEPTH | K'' / C =>1 V' & 
	 K' / L << (V <- F[TL, V', TL']) =>* R & 
	 RC || SC ; OVL ; s(NV) ; AN
	 if not (getType(C) in smtSorts) /\ (true - K'') := existsRule(C) /\ V' := newVar(NV, K'') .
	
  ceq c(DEPTH | K / F[TL, F'[NETL], TL'] =>1 V & K' / L =>* R & RC || SC ; OVL ; NV ; AN)
   = DEPTH | K'' / F'[NETL] =>1 V' & K' / L << (V <- F[TL, V', TL']) =>* R & RC || SC ; OVL ; s(NV) ; AN
	 if K in congruenceKinds1 /\ TY := leastSort(moduleNoRls, F'[NETL]) /\ not (TY in smtSorts) /\ 
	    K'' := getKind(moduleNoRls, TY) /\ K'' in congruenceKinds2 /\ V' := newVar(NV, K'') .
		
  eq c(NP) = nilNP [owise] .
		
  op n : KindIntSmtRuleSet NatProblem -> NatPrList .
  op n* : KindIntSmtRule NatProblem -> NatProblem .
  eq n(kNone, NP) = nilNP .
  eq n(K / RN / SRL KISRLS, NP)
   = n*(K / RN / SRL, NP) || n(KISRLS, NP) .
  ceq n*(K / RN / SRL, DEPTH | K / C =>1 V & K' / L =>* R & RC || SC ; OVL ; NV ; AN)
   = DEPTH | 1 / NV', L0, R', RC' / SU / C =>1 V & K' / L =>* R & RC || SC and term2cExpr(TC) ; OVL ; NV'' ; AN
	 if NV' ; L0 => R' if RC' && TC := freshRule(RN, SRL, NV) /\
	    {SU, NV''} := metaUnify(moduleNoRls, C =? L0, NV', 0) .
  ceq n*(K / RN / SRL, DEPTH | K / F[TL] =>1 V & K' / L =>* R & RC || SC ; OVL ; NV ; AN)
   = DEPTH | 1 / NV', L0, R', RC' / SU / F[TL] =>1 V & K' / L =>* R & RC || SC and term2cExpr(TC) ; OVL ; NV'' ; AN
	 if NV' ; L0 => R' if RC' && TC := freshRule(RN, SRL, NV) /\
	    {SU, NV''} := metaUnify(moduleNoRls, F[TL] =? L0, NV', 0) .
  eq n*(KISRL, NP) = nilNP [owise] .
  
  eq processNatPr(DEPTH | NA / NV', L0, R', RC' / SU / T =>1 V & K' / L =>* R & RC || SC ; OVL ; NV ; AN)
   = r1(DEPTH | NA / NV', L0, R', RC' / SU / T =>1 V & K' / L =>* R & RC || SC ; OVL ; NV ; AN) ||
     r2(DEPTH | NA / NV', L0, R', RC' / SU / T =>1 V & K' / L =>* R & RC || SC ; OVL ; NV ; AN) .

  op r1 : NatProblem -> NatProblem .
  ceq r1(DEPTH | NA / NV', L0, R', RC' / SU / T =>1 V & K' / L =>* R & RC || SC ; OVL ; NV ; AN)
   = DEPTH | s(NA) / NV', L0, R', RC' / SU' / T =>1 V & K' / L =>* R & RC || SC ; OVL ; NV'' ; AN
	 if {SU', NV''} := metaUnify(moduleNoRls, T =? L0, NV', NA) .
	 
  eq r1(NP) = nilNP [owise] .
	
  op r2 : NatProblem -> NatProblem .
  ceq r2(s(DEPTH) | NA / NV', L0, R', RC' / SU / T =>1 V & K' / L =>* R & RC || SC ; OVL ; NV ; AN)
	= DEPTH | simplifySatisfSC(
	          (RC' << SU) & K' / (L << SU') =>* (R << SU) & (RC << SU) || 
	          removeGSCs(SC') ; OVL ; NV ; 
		      (AN .. SU) |>* OVL, 'true.Boolean)
	  if SC' := (SC <<* su2smtSu(SU, smtParams)) /\ metaCheck(smtModule, downSmt(SC', false)) /\ SU' := (SU ; V <- (R' << SU)) .

  eq r2(NP) = nilNP [owise] .
	
	
************* DEFINED FUNCTIONS *******************
  
  op getVarSet : Term -> QidSet .
  op getVarSet* : TermList -> QidSet .
  op getVarSetRc : RuleCondi -> QidSet .
  op getVarSetOp : OrigPr -> QidSet .
  op getVarSetOpc : OrigPrCond -> QidSet .
  op getVarListOpc : OrigPrCond -> TermList .
  op vSet2vList : QidSet TermList -> TermList .
  
  op newVar : Int Type -> Variable . *** new var #s(Int):Type
  op abstract : Term Int -> TeTeInt .
  eq abstract(T, NV) =  normalizeTerm(T, 'true.Boolean, NV, leastSort(moduleNoRls, T)) .

  op freshSubst : QidSet UnificationPair -> UnificationPair .
  op freshRule : Int SmtRule Int -> IntSmtRule .
  op freshRule* : SmtRule UnificationPair -> IntSmtRule .
  op _<<_ : SmtRule Substitution -> SmtRule .
  op _<<_ : RuleCondi Substitution -> RuleCondi .



************** EQUATIONS **********************  

  eq newVar(NV, TY) = qid("#" + string(s(NV), 10) + ":" + string(TY) ) .    *** generate a variable #s(N):TY

  eq getVarSet(C) = none .
  eq getVarSet(V) = V .
  eq getVarSet(F[TL]) = getVarSet*(TL) .
  eq getVarSet*(empty) = none .
  eq getVarSet*(T) = getVarSet(T) .
  eq getVarSet*((T, TL)) = getVarSet(T) ; getVarSet*(TL) [owise] .
  eq getVarSetRc(nilR) = none .
  eq getVarSetRc(K / L =>* R & RC)
   = getVarSet(L) ; getVarSet(R) ; getVarSetRc(RC) .
  eq getVarSetOpc(OP && TC)
   = getVarSetOp(OP) ; getVarSet(TC) .
  eq getVarSetOp(nilOP) = none .
  eq getVarSetOp(L =>* R & OP)
   = getVarSet(L) ; getVarSet(R) ; getVarSetOp(OP) .

  eq getVarListOpc(OPC)
   = vSet2vList(getVarSetOpc(OPC), empty) . 
   
  eq vSet2vList(none, TL)
   = TL .
  eq vSet2vList(V ; VS, TL)
   = vSet2vList(VS, (TL, V)) [owise] .

  eq freshSubst(none, {SU, NV}) = {SU, NV} .
  eq freshSubst(V ; RVS, {SU, NV})
   = freshSubst(RVS, {SU ; V <- newVar(NV, getType(V)), NV + 1}) .

  eq freshRule(RN, SRL, NV)
   = freshRule*(SRL, freshSubst(getRuleVars(RN), {none, NV})) .
  eq freshRule*(SRL, {SU, NV})
   = NV ; (SRL << SU) .
   
  eq (L => R if RC && TC) << SU
   = (L << SU) => (R << SU) if (RC << SU) && (TC << SU) .
  eq nilR << SU = nilR .
  eq (K / L =>* R & RC) << SU
   = K / (L << SU) =>* (R << SU) & (RC << SU) .
   
  op simplifyRC : RuleCondi -> RuleCondi .
  op simplify : Term Type -> Term .
  op simplify* : TermList -> TermList .
  op simplifySatisfSC : Problem SmtCondi -> Problem .	
  op simplifySatisfSC0 : Problem SmtCondi -> Problem .	
  op simplifySatisfSC1 : Problem SmtCondi -> Problem .	
  op simplifySatisfSC2 : Problem SmtCondi -> Problem .	
  op simplifySatisfSC3 : Problem SmtCondi -> Problem .	
  op simplifySatisfSCSC : Problem SmtCondi Assignment -> Problem .	
  op simplifyAnswer : Substitution -> Substitution .
  op anyOf_in_ : QidSet Term -> Bool .
  op anyOf_inTL_ : QidSet TermList -> Bool .
  
  eq anyOf QS in V = false .
  eq anyOf QS in F[TL]
   = anyOf QS inTL TL .
  eq anyOf QS ; C ; QS' in C
   = true .
  eq anyOf QS in C
   = false [owise] .
  eq anyOf QS inTL empty
   = false .
  eq anyOf QS inTL (T, TL)
   = if anyOf QS in T
     then true
	 else anyOf QS inTL TL fi [owise] .
  
  eq simplifyAnswer(none) = none .
  eq simplifyAnswer(V <- T ; SU)
   = if anyOf smtVParams in T
     then V <- T ; simplifyAnswer(SU)
     else V <- simplify(T, getType(V)) ; simplifyAnswer(SU) fi .
  
  ceq simplifySatisfSC(RC || SC ; (TL, V, TL') ; NV ; (AN ; V <- V'), SC')      *** remove temporal variables #n
   = simplifySatisfSC(RC << (V' <- V) || SC <<* (V' <-* V) ; (TL, V, TL') ; NV ; (AN << (V' <- V)), SC')   
     if not (V' in (TL, TL')) .
  eq simplifySatisfSC(RC || SC and (V === 'true.Boolean) and (V === GSC') ; OVL ; NV ; AN, SC')
   = simplifySatisfSC(RC || SC and (V === 'true.Boolean) ; OVL ; NV ; AN, SC') .
  eq simplifySatisfSC(RC || SC and (V === 'true.Boolean) and (V =/== GSC') ; OVL ; NV ; AN, SC')
   = simplifySatisfSC(RC || SC and (V === 'true.Boolean) ; OVL ; NV ; AN, SC') .
  eq simplifySatisfSC(RC || SC and (V === 'false.Boolean) and (V === GSC') ; OVL ; NV ; AN, SC')
   = simplifySatisfSC(RC || SC and (V === 'false.Boolean) ; OVL ; NV ; AN, SC') .
  eq simplifySatisfSC(RC || SC and (V === 'false.Boolean) and (V =/== GSC') ; OVL ; NV ; AN, SC')
   = simplifySatisfSC(RC || SC and (V === 'false.Boolean) ; OVL ; NV ; AN, SC') .
  eq simplifySatisfSC(PR, SC')
   = simplifySatisfSC0(PR, SC') [owise] .

  eq simplifySatisfSC0(RC || SC and (V === GSC) and (V === GSC') ; OVL ; NV ; AN, SC')
   = simplifySatisfSC0(RC || SC and (V === GSC) ; OVL ; NV ; AN, SC') .
  eq simplifySatisfSC0(RC || SC and (V === GSC) and (V =/== GSC') ; OVL ; NV ; AN, SC')
   = simplifySatisfSC0(RC || SC and (V === GSC) ; OVL ; NV ; AN, SC') .
  eq simplifySatisfSC0(RC || SC and (V === GST) and (V === GST') ; OVL ; NV ; AN, SC')
   = simplifySatisfSC0(RC || SC and (V === GST) ; OVL ; NV ; AN, SC') .
  eq simplifySatisfSC0(RC || SC and (V === GST) and (V =/== GST') ; OVL ; NV ; AN, SC')
   = simplifySatisfSC0(RC || SC and (V === GST) ; OVL ; NV ; AN, SC') .
  eq simplifySatisfSC0(RC || SC and (V === GST) and (V < GST') ; OVL ; NV ; AN, SC')
   = simplifySatisfSC0(RC || SC and (V === GST) ; OVL ; NV ; AN, SC') .
  eq simplifySatisfSC0(RC || SC and (V === GST) and (V > GST') ; OVL ; NV ; AN, SC')
   = simplifySatisfSC0(RC || SC and (V === GST) ; OVL ; NV ; AN, SC') .
  eq simplifySatisfSC0(RC || SC and (V === GST) and (V <= GST') ; OVL ; NV ; AN, SC')
   = simplifySatisfSC0(RC || SC and (V === GST) ; OVL ; NV ; AN, SC') .
  eq simplifySatisfSC0(RC || SC and (V === GST) and (V >= GST') ; OVL ; NV ; AN, SC')
   = simplifySatisfSC0(RC || SC and (V === GST) ; OVL ; NV ; AN, SC') .
  eq simplifySatisfSC0(PR, SC')
   = simplifySatisfSC1(PR, SC') [owise] .
  
  op ..or<< : Substitution Assignment TermList -> Substitution .
  eq ..or<<(AN, V <- GST, OVL)
   = if V in OVL 
     then AN .. (V <- GST)
	 else AN << (V <- GST) fi .
  eq ..or<<(AN, V <- GSC, OVL)
   = if V in OVL 
     then AN .. (V <- GSC)
	 else AN << (V <- GSC) fi .

	 eq simplifySatisfSC1(RC || SC and (V === C) ; OVL ; NV ; AN, SC')
   = simplifySatisfSC1(RC << (V <- C) || SC <<* (V <-* C) ; OVL ; NV ; ..or<<(AN, V <- C, OVL), SC') .
  eq simplifySatisfSC1(PR, SC')
   = simplifySatisfSC2(PR, SC') [owise] .

  eq simplifySatisfSC2(RC || SC and (V === GSC) ; OVL ; NV ; AN, SC')
   = if metaCheck(smtModule, downSmt(GSC, false))     *** if true then V = true 
     then simplifySatisfSC2(RC << (V <- 'true.Boolean) || SC <<* (V <-* 'true.Boolean) ; 
                            OVL ; NV ; ..or<<(AN, V <- 'true.Boolean, OVL), SC')
	 else simplifySatisfSC2(RC << (V <- 'false.Boolean) || SC <<* (V <-* 'false.Boolean) ; 
	                        OVL ; NV ; (AN ; V <- 'false.Boolean), SC') fi .
  ceq simplifySatisfSC2(RC || SC and (V === GST) ; OVL ; NV ; AN, SC')
   = simplifySatisfSC2(RC << (V <- GST') || SC <<* (V <-* GST) ; OVL ; NV ; ..or<<(AN, V <- GST', OVL), SC') 
     if GST' := MaudeSort2SmtSort(downSmt(GST, true)) .
  eq simplifySatisfSC2(RC || SC ; OVL ; NV ; AN, SC')
    = RC || smtSimplify(removeGSCs(SC' and SC)) ; OVL ; NV ; AN [owise] .

  eq simplifyRC(nilR) = nilR .
  eq simplifyRC('`[Integer`] / L =>* R & RC)
   = '`[Integer`] / simplify(L, 'Integer) =>* simplify(R, 'Integer) & simplifyRC(RC) .
  eq simplifyRC('`[Boolean`] / L =>* R & RC)
   = '`[Boolean`] / simplify(L, 'Boolean) =>* simplify(R, 'Boolean) & simplifyRC(RC) .
  eq simplifyRC('`[Real`] / L =>* R & RC)
   = '`[Real`] / simplify(L, 'Real) =>* simplify(R, 'Real) & simplifyRC(RC) .
  eq simplifyRC('`[Real`] / L =>* R & RC)
   = '`[Real`] / simplify(L, 'Real) =>* simplify(R, 'Real) & simplifyRC(RC) .
  eq simplifyRC(TY / L =>* R & RC)
   = TY / simplify(L, TY) =>* simplify(R, TY) & simplifyRC(RC) [owise] .
  
  eq simplify(C, TY) = C .
  eq simplify(V, TY) = V .
  eq simplify(F[TL], 'Integer)
   = variables2constants(smtSimplifyA(term2iExpr(constants2variables(F[TL], smtParams))), smtVParams) .
  eq simplify(F[TL], 'Boolean)
   = variables2constants(smtSimplifyC(term2cExpr(constants2variables(F[TL], smtParams))), smtVParams) .
  eq simplify(F[TL], 'Real)
   = F[TL] .
  eq simplify(F[TL], TY)
   = F[simplify*(TL)] [owise] .
  eq simplify*(empty) = empty .
  eq simplify*((C, TL)) = C , simplify*(TL) .
  eq simplify*((V, TL)) = V , simplify*(TL) .
  eq simplify*((T, TL)) = simplify(T, leastSort(moduleNoRls, T)) , simplify*(TL) [owise] .
 
 
*************** VARIABLE RENAMING *************************

  op renameVars : Problem -> Problem .
  op renameVars* : Problem SubsPairInt -> Problem .
  op getSubstitutions : TermList Int SubsPairInt -> SubsPairInt .
  op getSubstitutions* : Variable Type Int SubsPairInt -> SubsPairInt .
  op getProblemVars : Problem -> TermList .
  op getRuleVars : RuleCondi TermList TermList -> TermList .
  op getAnswerVars : Substitution TermList TermList -> TermList .
  op getTermVars : Term TermList TermList -> TermList .
  op getTermListVars : TermList TermList TermList -> TermList .
  
  eq renameVars((RC || SC ; OVL ; NV ; AN))
   = renameVars*((RC || SC ; OVL ; NV ; AN), 
                 getSubstitutions(getProblemVars((RC || SC ; OVL ; NV ; AN)), NV, (none, none, 0))) .
  eq renameVars*((RC || SC ; OVL ; NV ; AN), (SU, SU', NV'))
   = (RC << SU) << SU' || (SC <<* su2smtSu(SU, none)) <<* su2smtSu(SU', none) ; 
     OVL ; NV' ; (AN << SU) << SU' .
	
  eq getSubstitutions(empty, NV, SPI)
   = SPI .
  eq getSubstitutions((V, TL), NV, SPI)
   = getSubstitutions(TL, s(NV), getSubstitutions*(V, getType(V), NV, SPI)) [owise] .
  eq getSubstitutions*(V, TY, NV, (SU, SU', NV'))
   = (V <- newVar(NV, TY) ; SU), (newVar(NV, TY) <- newVar(NV', TY) ; SU'), s(NV') . 
  eq getProblemVars(RC || SC ; OVL ; NV ; AN)
   = getAnswerVars(AN, OVL, getCondVars(SC, OVL, getRuleVars(RC, OVL, empty))) .
  eq getAnswerVars(none, OVL, TL) = TL .
  eq getAnswerVars(V <- T ; AN, OVL, TL)
   = getAnswerVars(AN, OVL, getTermVars(T, OVL, TL)) .
  eq getRuleVars(nilR, OVL, TL) = TL .
  eq getRuleVars(K / L =>* R & RC, OVL, TL)
   = getRuleVars(RC, OVL, getTermVars(R, OVL, getTermVars(L, OVL, TL))) .
  eq getTermVars(F[TL'], OVL, TL)
   = getTermListVars(TL', OVL, TL) .
  eq getTermVars(C, OVL, TL)
   = TL .
  eq getTermVars(V, (OVL, V, OVL'), TL)  *** variables from the original problem don't get renamed
   = TL .
  eq getTermVars(V, OVL, (TL, V, TL'))
   = TL, V, TL' .
  eq getTermVars(V, OVL, TL)
   = TL, V [owise] .
  eq getTermListVars(T, OVL, TL)
   = getTermVars(T, OVL, TL) .
  eq getTermListVars((T, TL'), OVL, TL)
   = getTermListVars(TL', OVL, getTermVars(T, OVL, TL)) [owise] .

endfm

