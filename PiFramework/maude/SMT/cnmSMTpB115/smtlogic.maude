*** load full-maude
load smt

fmod SMTLOGIC is 
  protecting INT .
  protecting REAL-INTEGER .
  protecting META-LEVEL .
  protecting SUBSTITUTION-HANDLING .

  sorts SmtATerm SmtTerm SmtCondi GroundSmtTerm GroundSmtCondi .
  subsort Term < SmtCondi .
  subsort Term < SmtATerm < SmtTerm .
  subsort GroundTerm < GroundSmtTerm < SmtATerm .
  subsort GroundTerm < GroundSmtCondi < SmtCondi .
  
  var F : Qid .
  var QQ : [Qid] .
  var Q : Qid .
  var S : String .
  var SP : QidSet .
  vars T T1 T2 : Term .
  var TL TL' OVL OVL' : TermList .
  var TY : Type .
  vars SC SC' SC1 SC2 : SmtCondi .
  vars ST ST' ST1 ST2 : SmtTerm .
  vars SAT SAT' : SmtATerm .
  vars GSC GSC' : GroundSmtCondi .
  vars GST GST' : GroundSmtTerm .
  vars M SM : Module .
  var AS : Assignment .
  vars SU SU' : Substitution .
  var SO : Sort .
  var SS : SortSet .
  var AtS : AttrSet .
  var OPD : OpDecl .
  var OPDS : OpDeclSet .
  var BO : Bool .
  vars C C' : Constant .
  vars V V' : Variable .

  op smtModule : -> Module [memo] .
  eq smtModule = upModule('REAL-INTEGER, false) .
  
  op smtSorts : -> SortSet [memo] .
  eq smtSorts = 'Integer ; 'Real ; 'Boolean .
  op smtKinds : -> KindSet [memo] .
  eq smtKinds = '`[Integer`] ; '`[Real`] ; '`[Boolean`] .
  
***  eq nonexec AtS = AtS .

  op not_ : SmtCondi -> SmtCondi [prec 53 ] .
  op _and_ : SmtCondi SmtCondi -> SmtCondi [assoc comm prec 55 ] .
  op _xor_ : SmtCondi SmtCondi -> SmtCondi [gather (E e) prec 57 ] .
  op _or_ : SmtCondi SmtCondi -> SmtCondi [assoc comm prec 59 ] .
  op _implies_ : SmtCondi SmtCondi -> SmtCondi [gather (e E) prec 61 ] .

  op not_ : GroundSmtCondi -> GroundSmtCondi [prec 53 ] .
  op _and_ : GroundSmtCondi GroundSmtCondi -> GroundSmtCondi [assoc comm prec 55 ] .
  op _xor_ : GroundSmtCondi GroundSmtCondi -> GroundSmtCondi [gather (E e) prec 57 ] .
  op _or_ : GroundSmtCondi GroundSmtCondi -> GroundSmtCondi [assoc comm prec 59 ] .
  op _implies_ : GroundSmtCondi GroundSmtCondi -> GroundSmtCondi [gather (e E) prec 61 ] .

  op _===_ : SmtCondi SmtCondi -> SmtCondi [gather (e E) prec 51 ] .
  op _===_ : GroundSmtCondi GroundSmtCondi -> GroundSmtCondi [ditto] .
  op _=/==_ : SmtCondi SmtCondi -> SmtCondi [gather (e E) prec 51 ] .
  op _=/==_ : GroundSmtCondi GroundSmtCondi -> GroundSmtCondi [ditto] .

  op _<_ : SmtTerm SmtTerm -> SmtCondi [prec 37 ] .
  op _<=_ : SmtTerm SmtTerm -> SmtCondi [prec 37 ] .
  op _>_ : SmtTerm SmtTerm -> SmtCondi [prec 37 ] .
  op _>=_ : SmtTerm SmtTerm -> SmtCondi [prec 37 ] .

  op _<_ : GroundSmtTerm GroundSmtTerm -> GroundSmtCondi [prec 37 ] .
  op _<=_ : GroundSmtTerm GroundSmtTerm -> GroundSmtCondi [prec 37 ] .
  op _>_ : GroundSmtTerm GroundSmtTerm -> GroundSmtCondi [prec 37 ] .
  op _>=_ : GroundSmtTerm GroundSmtTerm -> GroundSmtCondi [prec 37 ] .

  op _===_ : SmtTerm SmtTerm -> SmtCondi [gather (e E) prec 51 ] .
  op _===_ : GroundSmtTerm GroundSmtTerm -> GroundSmtCondi [ditto] .
  op _=/==_ : SmtTerm SmtTerm -> SmtCondi [gather (e E) prec 51 ] .
  op _=/==_ : GroundSmtTerm GroundSmtTerm -> GroundSmtCondi [ditto] .

  op _?_:_ : SmtCondi SmtCondi SmtCondi -> SmtCondi [gather (e e e) prec 71 ] .
  op _?_:_ : SmtCondi Term Term -> Term [ditto] .
  op _?_:_ : SmtCondi SmtTerm SmtTerm -> SmtTerm [ditto] .
  op _?_:_ : GroundSmtCondi SmtATerm SmtATerm -> SmtATerm [ditto] .

  op _?_:_ : GroundSmtCondi GroundTerm GroundTerm -> GroundTerm [ditto] .
  op _?_:_ : GroundSmtCondi GroundSmtTerm GroundSmtTerm -> GroundSmtTerm [ditto] .
  op _?_:_ : GroundSmtCondi GroundSmtCondi GroundSmtCondi -> GroundSmtCondi [ditto] .

  *** seems to break CVC4
  op _divisible_ : SmtTerm SmtTerm -> SmtCondi [prec 51] .
  op _divisible_ : GroundSmtTerm GroundSmtTerm -> GroundSmtCondi [prec 51] .

  op -I_ : SmtTerm -> SmtTerm [prec 29 ] .
  op _+I_ : SmtTerm SmtTerm -> SmtTerm [assoc comm prec 33 ] .
  op _*I_ : SmtTerm SmtTerm -> SmtTerm [assoc comm prec 31 ] .
  op _-I_ : SmtTerm SmtTerm -> SmtTerm [gather (E e) prec 33 ] .
  op _div_ : SmtTerm SmtTerm -> SmtTerm [gather (E e) prec 31 ] .
  op _mod_ : SmtTerm SmtTerm -> SmtTerm [gather (E e) prec 31 ] .
  op toReal : SmtTerm -> SmtTerm .

  op -R_ : SmtTerm -> SmtTerm [prec 29 ] .
  op _+R_ : SmtTerm SmtTerm -> SmtTerm [assoc comm prec 33 ] .
  op _*R_ : SmtTerm SmtTerm -> SmtTerm [assoc comm prec 31 ] .
  op _-R_ : SmtTerm SmtTerm -> SmtTerm [gather (E e) prec 33 ] .
  op _/_ : SmtTerm SmtTerm -> SmtTerm [gather (E e) prec 31 ] .
  op toInteger : SmtTerm -> SmtTerm .
  op isInteger : SmtTerm -> SmtCondi .

  op -I_ : SmtATerm -> SmtATerm [prec 29 ] .
  op _+I_ : SmtATerm SmtATerm -> SmtATerm [assoc comm prec 33 ] .
  op _*I_ : SmtATerm SmtATerm -> SmtATerm [assoc comm prec 31 ] .
  op _-I_ : SmtATerm SmtATerm -> SmtATerm [gather (E e) prec 33 ] .
  op _div_ : SmtATerm SmtATerm -> SmtATerm [gather (E e) prec 31 ] .
  op _mod_ : SmtATerm SmtATerm -> SmtATerm [gather (E e) prec 31 ] .

  op -R_ : SmtATerm -> SmtTerm [prec 29 ] .
  op _+R_ : SmtATerm SmtATerm -> SmtTerm [assoc comm prec 33 ] .
  op _*R_ : SmtATerm SmtATerm -> SmtTerm [assoc comm prec 31 ] .
  op _-R_ : SmtATerm SmtATerm -> SmtTerm [gather (E e) prec 33 ] .
  op _/_ : SmtATerm SmtATerm -> SmtTerm [gather (E e) prec 31 ] .
  op toReal : SmtATerm -> SmtTerm .
  op toInteger : SmtATerm -> SmtTerm .

  op -I_ : GroundSmtTerm -> GroundSmtTerm [prec 29 ] .
  op _+I_ : GroundSmtTerm GroundSmtTerm -> GroundSmtTerm [assoc comm prec 33 ] .
  op _*I_ : GroundSmtTerm GroundSmtTerm -> GroundSmtTerm [assoc comm prec 31 ] .
  op _-I_ : GroundSmtTerm GroundSmtTerm -> GroundSmtTerm [gather (E e) prec 33 ] .
  op _div_ : GroundSmtTerm GroundSmtTerm -> GroundSmtTerm [gather (E e) prec 31 ] .
  op _mod_ : GroundSmtTerm GroundSmtTerm -> GroundSmtTerm [gather (E e) prec 31 ] .
  op toReal : GroundSmtTerm -> SmtTerm .

  op -R_ : GroundSmtTerm -> GroundSmtTerm [prec 29 ] .
  op _+R_ : GroundSmtTerm GroundSmtTerm -> GroundSmtTerm [assoc comm prec 33 ] .
  op _*R_ : GroundSmtTerm GroundSmtTerm -> GroundSmtTerm [assoc comm prec 31 ] .
  op _-R_ : GroundSmtTerm GroundSmtTerm -> GroundSmtTerm [gather (E e) prec 33 ] .
  op _/_ : GroundSmtTerm GroundSmtTerm -> GroundSmtTerm [gather (E e) prec 31 ] .
  op toInteger : GroundSmtTerm -> SmtTerm .
  op isInteger : GroundSmtTerm -> SmtCondi .

  eq GSC === V = V === GSC .
  eq GSC =/== V = V =/== GSC .
  eq V =/== GSC = V === (not GSC) .
  eq SC and SC = SC . 
  eq (SC === SC') and (SC' === SC) = SC === SC' . 
  eq (SC =/== SC') and (SC' =/== SC) = SC =/== SC' . 
  eq SC or SC = SC . 
  eq (SC === SC') or (SC' === SC) = SC === SC' . 
  eq (SC =/== SC') or (SC' =/== SC) = SC =/== SC' . 
  eq 'true.Boolean and SC = SC .
  eq 'false.Boolean and SC = 'false.Boolean .
  eq 'false.Boolean or SC = SC .
  eq 'true.Boolean or SC = 'true.Boolean .
  eq 'true.Boolean xor SC = not SC .
  eq 'false.Boolean xor SC = SC .
  eq SC xor SC = 'false.Boolean .
  eq SC xor not SC = 'true.Boolean .
  eq not SC xor SC = 'true.Boolean .
  eq not 'true.Boolean = 'false.Boolean .
  eq not 'false.Boolean = 'true.Boolean .
  
  eq SC === SC = 'true.Boolean .
  eq SC =/== SC = 'false.Boolean .
  eq 'true.Boolean === SC = SC .
  eq 'false.Boolean === SC = not SC .
  eq 'true.Boolean =/== 'false.Boolean = 'true.Boolean .
  eq 'false.Boolean =/== 'true.Boolean = 'true.Boolean .
  eq 'false.Boolean implies SC = 'true.Boolean .
  eq ('true.Boolean ? SC : SC') = SC .
  eq ('false.Boolean ? SC : SC') = SC' .
  eq (SC ? SC' : SC') = SC' .

  eq C === C' = if (getName(C) == getName(C')) then 'true.Boolean else 'false.Boolean fi .
  eq C =/== C' = if (getName(C) == getName(C')) then 'false.Boolean else 'true.Boolean fi .

  eq GST === V = V === GST . 
  eq GST =/== V = V =/== GST . 
  eq GST < V = V > GST . 
  eq GST <= V = V >= GST . 
  eq GST >= V = V <= GST . 
  eq GST > V = V < GST . 
  eq (ST1 === ST2) and (ST2 === ST1) = ST1 === ST2 . 
  eq (SAT === SAT') and (SAT <= SAT') = SAT === SAT' . 
  eq (SAT === SAT') and (SAT >= SAT') = SAT === SAT' . 
  eq (ST1 === ST2) or (ST2 === ST1) = ST1 === ST2 . 
  eq (ST1 =/== ST2) and (ST2 =/== ST1) = ST1 =/== ST2 . 
  eq (ST1 =/== ST2) or (ST2 =/== ST1) = ST1 =/== ST2 . 
  eq ST === ST = 'true.Boolean .
  eq ST =/== ST = 'false.Boolean .
  eq ST <= ST = 'true.Boolean .
  eq ST >= ST = 'true.Boolean .
  eq ST < ST = 'false.Boolean .
  eq ST > ST = 'false.Boolean .
  eq ('true.Boolean ? ST1 : ST2) = ST1 .
  eq ('false.Boolean ? ST1 : ST2) = ST2 .
  eq (SC ? ST1 : ST1) = ST1 .

  eq ST <= ST = 'true.Boolean .
  eq ST >= ST = 'true.Boolean .
  eq ST < ST = 'false.Boolean .
  eq ST > ST = 'false.Boolean .
  eq ('true.Boolean ? ST1 : ST2) = ST1 .
  eq ('false.Boolean ? ST1 : ST2) = ST2 .
  eq (SC ? ST1 : ST1) = ST1 .

  eq -I '0.Integer = '0.Integer .
  eq '0.Integer +I ST = ST .
  eq ((ST1) *I ST) +I ((ST2) *I ST)
   = (ST1 +I ST2) *I ST .
  eq '1.Integer *I ST = ST .
  eq '0.Integer *I ST = '0.Integer .
  eq '0.Integer -I ST = -I ST .
  eq ST -I '0.Integer = ST .
  eq ST -I ST = '0.Integer .
  eq ST1 +I (-I ST2) = ST1 -I ST2 [owise] .
  eq ST div '1.Integer = ST .
***  eq '1.Integer mod ST = '1.Integer .
***  eq '0.Integer mod ST = '0.Integer .
***  eq ST mod ST = '0.Integer .
***  eq (ST * ST') mod ST = '0.Integer .
***  eq (ST +I ST') mod ST = ST' .
***  eq '0.Integer div ST = '0.Integer .

  eq (V <= ST) and (V >= ST) = V === ST .

  eq (ST +I C) === GST = ST === (GST +I (-I C)) .
  eq (ST -I C) === GST = ST === (GST +I C) .
  eq (C +I ST) === GST = ST === (GST +I (-I C)) .
  eq (C -I ST) === GST = ST === (C +I (-I GST)) .
  eq GST === (V +I C) = V === (GST +I (-I C)) .
  eq GST === (V -I C) = V === (GST +I C) .
  eq GST === (C +I V) = V === (GST +I (-I C)) .
  eq GST === (C -I V) = V === (C +I (-I GST)) .

  eq (ST +I C) =/== GST = ST =/== (GST +I (-I C)) .
  eq (ST -I C) =/== GST = ST =/== (GST +I C) .
  eq (C +I ST) =/== GST = ST =/== (GST +I (-I C)) .
  eq (C -I ST) =/== GST = ST =/== (C +I (-I GST)) .
  eq GST =/== (V +I C) = V =/== (GST +I (-I C)) .
  eq GST =/== (V -I C) = V =/== (GST +I C) .
  eq GST =/== (C +I V) = V =/== (GST +I (-I C)) .
  eq GST =/== (C -I V) = V =/== (C +I (-I GST)) .

  eq (ST +I C) < GST = ST < (GST +I (-I C)) .
  eq (ST -I C) < GST = ST < (GST +I C) .
  eq (C +I ST) < GST = ST < (GST +I (-I C)) .
  eq (C -I ST) < GST = ST < (C +I (-I GST)) .
  eq GST > (V +I C) = V < (GST +I (-I C)) .
  eq GST > (V -I C) = V < (GST +I C) .
  eq GST > (C +I V) = V < (GST +I (-I C)) .
  eq GST > (C -I V) = V < (C +I (-I GST)) .

  eq (ST +I C) > GST = ST > (GST +I (-I C)) .
  eq (ST -I C) > GST = ST > (GST +I C) .
  eq (C +I ST) > GST = ST > (GST +I (-I C)) .
  eq (C -I ST) > GST = ST > (C +I (-I GST)) .
  eq GST < (V +I C) = V > (GST +I (-I C)) .
  eq GST < (V -I C) = V > (GST +I C) .
  eq GST < (C +I V) = V > (GST +I (-I C)) .
  eq GST < (C -I V) = V > (C +I (-I GST)) .

  eq (ST +I C) <= GST = ST <= (GST +I (-I C)) .
  eq (ST -I C) <= GST = ST <= (GST +I C) .
  eq (C +I ST) <= GST = ST <= (GST +I (-I C)) .
  eq (C -I ST) <= GST = ST <= (C +I (-I GST)) .
  eq GST >= (V +I C) = V <= (GST +I (-I C)) .
  eq GST >= (V -I C) = V <= (GST +I C) .
  eq GST >= (C +I V) = V <= (GST +I (-I C)) .
  eq GST >= (C -I V) = V <= (C +I (-I GST)) .

  eq (ST +I C) >= GST = ST >= (GST +I (-I C)) .
  eq (ST -I C) >= GST = ST >= (GST +I C) .
  eq (C +I ST) >= GST = ST >= (GST +I (-I C)) .
  eq (C -I ST) >= GST = ST >= (C +I (-I GST)) .
  eq GST <= (V +I C) = V >= (GST +I (-I C)) .
  eq GST <= (V -I C) = V >= (GST +I C) .
  eq GST <= (C +I V) = V >= (GST +I (-I C)) .
  eq GST <= (C -I V) = V >= (C +I (-I GST)) .

  eq -R '0/1.Real = '0/1.Real .
  eq '0/1.Real +R ST = ST .
  eq ((ST1) *R ST) +R ((ST2) *R ST)
   = (ST1 +R ST2) *R ST .
  eq '0/1.Real -R ST = -R ST .
  eq '1/1.Real *R ST = ST .
  eq '0/1.Real *R ST = '0/1.Real .
  eq ST -R ST = '0/1.Real .
  eq ST -R '0/1.Real = ST .
  eq ST / '1/1.Real = ST .
***  eq '0/1.Real / ST = '0/1.Real .


  op cond2smtCond : Qid Term Type Term Type -> SmtCondi .
  op term2iExpr : Term -> SmtTerm .
  op term2rExpr : Term -> SmtTerm .
  op tl2smtTl : TermList -> TermList .
  op term2cExpr : Term -> SmtCondi .
  op downSmt : SmtCondi Bool -> Term .   *** true: convert smt types to Maude types
  op downSmtC : String Type -> Qid .
  op downSmtV : String Type -> Qid .
  op removeGSCs : SmtCondi -> SmtCondi .
  op smtSimplify : SmtCondi -> SmtCondi .
  op smtSimplify* : SmtCondi -> SmtCondi .
  op smtSimplify** : SmtCondi -> SmtCondi .
  op smtSimplify*** : SmtCondi -> SmtCondi .
  op smtSimplifyC : SmtCondi -> Term .
  op smtSimplifyA : SmtATerm -> Term .

  eq '_-_[T1, T2] = '_+_[T1, '-_[T2]] .  

  eq smtSimplify(C) = C .
  eq smtSimplify(V) = V .
  eq smtSimplify(GST) = term2iExpr(smtSimplifyA(GST)) .
  eq smtSimplify(SAT) = term2iExpr(smtSimplifyA(SAT)) .
  eq smtSimplify(SC) = smtSimplify*(SC) [owise] .
  eq smtSimplify*(GSC)
   = term2cExpr(smtSimplifyC(GSC)) .
  eq smtSimplify*(SC and SC')
   = smtSimplify(SC) and smtSimplify(SC') .
  eq smtSimplify*(SC)
   = smtSimplify**(SC) [owise] .

  eq smtSimplify**(GSC === SC)
   = smtSimplify(GSC) === SC .
  eq smtSimplify**(SC === GSC)
   = smtSimplify(GSC) === SC .
  eq smtSimplify**(GSC =/== SC)
   = smtSimplify(GSC) =/== SC .
  eq smtSimplify**(SC =/== GSC)
   = smtSimplify(GSC) =/== SC .

  eq smtSimplify**(SAT === SAT')
   = smtSimplify(SAT) === smtSimplify(SAT') .
  eq smtSimplify**(SAT =/== SAT')
   = smtSimplify(SAT) =/== smtSimplify(SAT') .
  eq smtSimplify**(SAT < SAT')
   = smtSimplify(SAT) < smtSimplify(SAT') .
  eq smtSimplify**(SAT > SAT')
   = smtSimplify(SAT) > smtSimplify(SAT') .
  eq smtSimplify**(SAT <= SAT')
   = smtSimplify(SAT) <= smtSimplify(SAT') .
  eq smtSimplify**(SAT >= SAT')
   = smtSimplify(SAT) >= smtSimplify(SAT') .
  eq smtSimplify**(SC)
   = smtSimplify***(SC) [owise] .


  eq smtSimplify***(SAT === ST)
   = smtSimplify(SAT) === ST .
  eq smtSimplify***(ST === SAT)
   = smtSimplify(SAT) === ST .
  eq smtSimplify***(SAT =/== ST)
   = smtSimplify(SAT) =/== ST .
  eq smtSimplify***(ST =/== SAT)
   = smtSimplify(SAT) =/== ST .
  eq smtSimplify***(SAT < ST)
   = smtSimplify(SAT) < ST .
  eq smtSimplify***(SAT > ST)
   = smtSimplify(SAT) > ST .
  eq smtSimplify***(SAT <= ST)
   = smtSimplify(SAT) <= ST .
  eq smtSimplify***(SAT >= ST)
   = smtSimplify(SAT) >= ST .
  eq smtSimplify***(ST < SAT)
   = ST < smtSimplify(SAT) .
  eq smtSimplify***(ST > SAT)
   = ST > smtSimplify(SAT) .
  eq smtSimplify***(ST <= SAT)
   = ST <= smtSimplify(SAT) .
  eq smtSimplify***(ST >= SAT)
   = ST >= smtSimplify(SAT) .
  eq smtSimplify***(SC) = SC [owise] .      **************************************************** ¡MEJORAR! *********************************
  
  eq smtSimplifyC(C)
   = C .
  eq smtSimplifyC(V)
   = V .
  eq smtSimplifyC(GSC)
   =  MaudeSort2SmtSort(upTerm(downTerm(downSmt(GSC, true), (false).Boolean))) [owise] . 
  eq smtSimplifyA(C)
   = C .
  eq smtSimplifyA(V)
   = V .
  eq smtSimplifyA(SAT)
   =  MaudeSort2SmtSort(upTerm(downTerm(downSmt(SAT, true), (9999).NzNat))) [owise] . 
   
  eq removeGSCs(GSC)
   = 'true.Boolean .
  eq removeGSCs(GSC and SC)
   = removeGSCs(SC) .
  eq removeGSCs(SC)
   =  SC [owise] .
   
  eq term2cExpr(C) = C .
  eq term2cExpr(V) = V .
  eq term2cExpr('not_[T]) = not term2cExpr(T) .
  eq term2cExpr('_and_[T1,T2]) = term2cExpr(T1) and term2cExpr(T2) .
  eq term2cExpr('_xor_[T1,T2]) = term2cExpr(T1) xor term2cExpr(T2) .
  eq term2cExpr('_or_[T1,T2]) = term2cExpr(T1) or term2cExpr(T2) .
  eq term2cExpr('_implies_[T1,T2]) = term2cExpr(T1) implies term2cExpr(T2) .
  eq term2cExpr('_?_:_[T,T1,T2]) = term2cExpr(T) ? term2cExpr(T1) : term2cExpr(T2) .
  eq term2cExpr('_divisible_[T1,T2]) = term2iExpr(T1) divisible term2iExpr(T2) .
  eq term2cExpr('isInteger[T1]) = isInteger(term2rExpr(T1)) .
  eq term2cExpr(F[T1,T2]) = cond2smtCond(F, T1, leastSort(smtModule, T1), T2, leastSort(smtModule, T2)) [owise] .

  eq cond2smtCond('_===_ , T1, 'Boolean, T2, 'Boolean) = term2cExpr(T1) === term2cExpr(T2) .
  eq cond2smtCond('_===_ , T1, 'Integer, T2, 'Integer) = term2iExpr(T1) === term2iExpr(T2) .
  eq cond2smtCond('_===_ , T1, 'Real, T2, 'Real) = term2rExpr(T1) === term2rExpr(T2) .
  eq cond2smtCond('_=/==_ , T1, 'Boolean, T2, 'Boolean) = term2cExpr(T1) =/== term2cExpr(T2) .
  eq cond2smtCond('_=/==_ , T1, 'Integer, T2, 'Integer) = term2iExpr(T1) =/== term2iExpr(T2) .
  eq cond2smtCond('_=/==_ , T1, 'Real, T2, 'Real) = term2rExpr(T1) =/== term2rExpr(T2) .
  eq cond2smtCond('_<_ , T1, 'Integer, T2, 'Integer) = term2iExpr(T1) < term2iExpr(T2) .
  eq cond2smtCond('_<_ , T1, 'Real, T2, 'Real) = term2rExpr(T1) < term2rExpr(T2) .
  eq cond2smtCond('_<=_ , T1, 'Integer, T2, 'Integer) = term2iExpr(T1) <= term2iExpr(T2) .
  eq cond2smtCond('_<=_ , T1, 'Real, T2, 'Real) = term2rExpr(T1) <= term2iExpr(T2) .
  eq cond2smtCond('_>_ , T1, 'Integer, T2, 'Integer) = term2iExpr(T1) > term2iExpr(T2) .
  eq cond2smtCond('_>_ , T1, 'Real, T2, 'Real) = term2rExpr(T1) > term2rExpr(T2) .
  eq cond2smtCond('_>=_ , T1, 'Integer, T2, 'Integer) = term2iExpr(T1) >= term2iExpr(T2) .
  eq cond2smtCond('_>=_ , T1, 'Real, T2, 'Real) = term2rExpr(T1) >= term2rExpr(T2) .

  eq term2iExpr(V) = V .
  eq term2iExpr(C) = C .
  eq term2iExpr('-_[T]) = -I term2iExpr(T) .
  eq term2iExpr('_+_[T1,T2]) = term2iExpr(T1) +I term2iExpr(T2) .
  eq term2iExpr('_-_[T1,T2]) = term2iExpr(T1) -I term2iExpr(T2) .
  eq term2iExpr('_*_[T1,T2]) = term2iExpr(T1) *I term2iExpr(T2) .
  eq term2iExpr('_?_:_[T,T1,T2]) = term2cExpr(T) ? term2iExpr(T1) : term2iExpr(T2) .
  eq term2iExpr('_div_[T1,T2]) = term2iExpr(T1) div term2iExpr(T2) .
  eq term2iExpr('_mod_[T1,T2]) = term2iExpr(T1) mod term2iExpr(T2) .
  eq term2iExpr('toInteger[T]) = toInteger(term2rExpr(T)) .

  eq term2rExpr(V) = V .
  eq term2rExpr(C) = C .
  eq term2rExpr('-_[T]) = -R term2rExpr(T) .
  eq term2rExpr('_+_[T1,T2]) = term2rExpr(T1) +R term2rExpr(T2) .
  eq term2rExpr('_-_[T1,T2]) = term2rExpr(T1) -R term2rExpr(T2) .
  eq term2rExpr('_*_[T1,T2]) = term2rExpr(T1) *R term2rExpr(T2) .
  eq term2rExpr('_?_:_[T,T1,T2]) = term2cExpr(T) ? term2rExpr(T1) : term2rExpr(T2) .
  eq term2rExpr('_/_[T1,T2]) = term2rExpr(T1) / term2rExpr(T2) .
  eq term2rExpr('toReal[T]) = toReal(term2iExpr(T)) .

  eq downSmt(not SC, BO) = 'not_[downSmt(SC, BO)] .
  eq downSmt(SC and SC', BO) = '_and_[downSmt(SC, BO),downSmt(SC', BO)] .
  eq downSmt(SC xor SC', BO) = '_xor_[downSmt(SC, BO),downSmt(SC', BO)] .
  eq downSmt(SC or SC', BO) = '_or_[downSmt(SC, BO),downSmt(SC', BO)] .
  eq downSmt(SC implies SC', BO) = '_implies_[downSmt(SC, BO),downSmt(SC', BO)] .
  eq downSmt(SC === SC', true) = '_==_[downSmt(SC, true),downSmt(SC', true)] .
  eq downSmt(SC =/== SC', true) = '_=/=_[downSmt(SC, true),downSmt(SC', true)] .
  eq downSmt(SC === SC', false) = '_===_[downSmt(SC, false),downSmt(SC', false)] .
  eq downSmt(SC =/== SC', false) = '_=/==_[downSmt(SC, false),downSmt(SC', false)] .

  eq downSmt(ST1 === ST2, true) = '_==_[downSmt(ST1, true),downSmt(ST2, true)] .
  eq downSmt(ST1 =/== ST2, true) = '_=/=_[downSmt(ST1, true),downSmt(ST2, true)] .
  eq downSmt(ST1 === ST2, false) = '_===_[downSmt(ST1, false),downSmt(ST2, false)] .
  eq downSmt(ST1 =/== ST2, false) = '_=/==_[downSmt(ST1, false),downSmt(ST2, false)] .
  eq downSmt(ST1 < ST2, BO) = '_<_[downSmt(ST1, BO),downSmt(ST2, BO)] .
  eq downSmt(ST1 <= ST2, BO) = '_<=_[downSmt(ST1, BO),downSmt(ST2, BO)] .
  eq downSmt(ST1 > ST2, BO) = '_>_[downSmt(ST1, BO),downSmt(ST2, BO)] .
  eq downSmt(ST1 >= ST2, BO) = '_>=_[downSmt(ST1, BO),downSmt(ST2, BO)] .
  eq downSmt(ST1 divisible ST2, BO) = '_divisible_[downSmt(ST1, BO),downSmt(ST2, BO)] .
  eq downSmt(isInteger(ST), BO) = 'isInteger[downSmt(ST, BO)] .

  eq downSmt(-I ST, BO) = '-_[downSmt(ST, BO)] .
  eq downSmt(-R ST, BO) = '-_[downSmt(ST, BO)] .
  eq downSmt(ST1 +I ST2, BO) = '_+_[downSmt(ST1, BO),downSmt(ST2, BO)] .
  eq downSmt(ST1 +R ST2, BO) = '_+_[downSmt(ST1, BO),downSmt(ST2, BO)] .
  eq downSmt(ST1 -I ST2, BO) = '_-_[downSmt(ST1, BO),downSmt(ST2, BO)] .
  eq downSmt(ST1 -R ST2, BO) = '_-_[downSmt(ST1, BO),downSmt(ST2, BO)] .
  eq downSmt(ST1 *I ST2, BO) = '_*_[downSmt(ST1, BO),downSmt(ST2, BO)] .
  eq downSmt(ST1 *R ST2, BO) = '_*_[downSmt(ST1, BO),downSmt(ST2, BO)] .
  eq downSmt(ST1 div ST2, BO) = '_div_[downSmt(ST1, BO),downSmt(ST2, BO)] .
  eq downSmt(ST1 mod ST2, BO) = '_mod_[downSmt(ST1, BO),downSmt(ST2, BO)] .
  eq downSmt(ST1 / ST2, BO) = '_/_[downSmt(ST1, BO),downSmt(ST2, BO)] .
  eq downSmt(toReal(ST), BO) = 'toReal[downSmt(ST, BO)] .
  eq downSmt(toInteger(ST), BO) = 'toInteger[downSmt(ST, BO)] .
  eq downSmt(C, false) = C .
  eq downSmt(V, false) = V .
  eq downSmt(C, true) = downSmtC(string(getName(C)), getType(C)) .
  eq downSmt(V, true) = downSmtV(string(getName(V)), getType(V)) .
  eq downSmtC(S, 'Boolean) = qid(S + ".Bool") .
  eq downSmtC(S, 'Integer) =  qid("s_^" + S)['0.Zero] .
  eq downSmtC(S, 'Real) = qid(S + ".Rat") .
  eq downSmtV(S, 'Boolean) = qid(S + ":Bool") .
  eq downSmtV(S, 'Integer) = qid(S + ":Int") .
  eq downSmtV(S, 'Real) = qid(S + ":Rat") .
  
  op _<<*_ : Term Substitution -> Term .
  op _<<*_ : SmtTerm Substitution -> SmtTerm .
  op _<<*_ : SmtCondi Substitution -> SmtCondi .

  *** applies a substitution to a condition in term form
  *** then it computes the smtcondition turning the
  *** parameterized constants into variables

  eq ST <<* none = ST .
  eq ST <<* none = ST .
  eq SC <<* none = SC .
  eq (not SC) <<* SU 
   = not (SC <<* SU) .
  eq (SC1 and SC2) <<* SU 
   = (SC1 <<* SU) and (SC2 <<* SU) .
  eq (SC1 or SC2) <<* SU 
   = (SC1 <<* SU) or (SC2 <<* SU) .
  eq (SC1 xor SC2) <<* SU 
   = (SC1 <<* SU) xor (SC2 <<* SU) .
  eq (SC1 implies SC2) <<* SU 
   = (SC1 <<* SU) implies (SC2 <<* SU) .
  eq (ST1 < ST2) <<* SU 
   = (ST1 <<* SU) < (ST2 <<* SU) .
  eq (ST1 <= ST2) <<* SU 
   = (ST1 <<* SU) <= (ST2 <<* SU) .
  eq (ST1 > ST2) <<* SU 
   = (ST1 <<* SU) > (ST2 <<* SU) .
  eq (ST1 >= ST2) <<* SU 
   = (ST1 <<* SU) >= (ST2 <<* SU) .
  eq (SC1 === SC2) <<* SU 
   = (SC1 <<* SU) === (SC2 <<* SU) .
  eq (SC1 =/== SC2) <<* SU 
   = (SC1 <<* SU) =/== (SC2 <<* SU) .
  eq (ST1 === ST2) <<* SU 
   = (ST1 <<* SU) === (ST2 <<* SU) .
  eq (ST1 =/== ST2) <<* SU 
   = (ST1 <<* SU) =/== (ST2 <<* SU) .
  eq (SC ? ST1 : ST2) <<* SU 
   = (SC <<* SU) ? (ST1 <<* SU) : (ST2 <<* SU) .
  eq (SC ? ST1 : ST2) <<* SU 
   = (SC <<* SU) ? (ST1 <<* SU) : (ST2 <<* SU) .
  eq (SC ? SC1 : SC2) <<* SU 
   = (SC <<* SU) ? (SC1 <<* SU) : (SC2 <<* SU) .
  eq (ST1 divisible ST2) <<* SU 
   = (ST1 <<* SU) divisible (ST2 <<* SU) .

  eq (-I ST) <<* SU 
   = -I (ST <<* SU) .
  eq (-R ST) <<* SU 
   = -R (ST <<* SU) .
  eq (ST1 +I ST2) <<* SU 
   = (ST1 <<* SU) +I (ST2 <<* SU) .
  eq (ST1 +R ST2) <<* SU 
   = (ST1 <<* SU) +R (ST2 <<* SU) .
  eq (ST1 *I ST2) <<* SU 
   = (ST1 <<* SU) *I (ST2 <<* SU) .
  eq (ST1 *R ST2) <<* SU 
   = (ST1 <<* SU) *R (ST2 <<* SU) .
  eq (ST1 -I ST2) <<* SU 
   = (ST1 <<* SU) -I (ST2 <<* SU) .
  eq (ST1 -R ST2) <<* SU 
   = (ST1 <<* SU) -R (ST2 <<* SU) .
  eq (ST1 div ST2) <<* SU 
   = (ST1 <<* SU) div (ST2 <<* SU) .
  eq (ST1 mod ST2) <<* SU 
   = (ST1 <<* SU) mod (ST2 <<* SU) .
  eq (ST1 / ST2) <<* SU 
   = (ST1 <<* SU) / (ST2 <<* SU) .
  eq toReal(ST) <<* SU
   = toReal(ST <<* SU) .
  eq toInteger(ST) <<* SU 
   = toInteger(ST <<* SU) .
  eq isInteger(ST) <<* SU 
   = isInteger(ST <<* SU) .

  eq C <<* SU = C .
  eq V <<* ((V <-* ST) ; SU) = ST .
  eq V <<* ((V <-* SC) ; SU) = SC .
  eq V <<* SU = V [owise] .

  op _<-*_ : Variable SmtTerm -> Assignment [ctor prec 63 format (nt d d d)] .
  op _<-*_ : Variable SmtTerm -> Assignment [ctor prec 63 format (nt d d d)] .
  op _<-*_ : Variable SmtCondi -> Assignment [ctor prec 63 format (nt d d d)] .
  op su2smtSu : Substitution QidSet -> Substitution .
  op su2smtSu* : Assignment Substitution Type QidSet -> Substitution .
  
  eq su2smtSu(none, SP) = none .
  eq su2smtSu(V <- V' ; SU, SP) = V <-* V' ; su2smtSu(SU, SP) .
  eq su2smtSu(V <- F[TL] ; SU, SP) = su2smtSu*(V <- F[TL] , SU, getType(V), SP) .
  eq su2smtSu(V <- C ; SU, SP) = su2smtSu*(V <- C , SU, getType(V), SP) .
  eq su2smtSu*(V <- T , SU, 'Integer, SP)
   = V <-* smtSimplify(term2iExpr(constants2variables(T, SP))) ; su2smtSu(SU, SP) .
  eq su2smtSu*(V <- T , SU, 'Real, SP)
   = V <-* smtSimplify(term2rExpr(constants2variables(T, SP))) ; su2smtSu(SU, SP) .
  eq su2smtSu*(V <- T , SU, 'Boolean, SP)
   = V <-* smtSimplify(term2cExpr(constants2variables(T, SP))) ; su2smtSu(SU, SP) .
  eq su2smtSu*(V <- T , SU, TY, SP)
   = su2smtSu(SU, SP) [owise] .
  
  op smtConst2smtVar : Constant -> Variable [memo] .
  op smtVar2smtConst : Variable -> Constant [memo] .
  op constants2variables : Term QidSet -> Term .
  op constants2variables* : TermList QidSet -> TermList .
  op variables2constants : Term QidSet -> Term .
  op variables2constants* : TermList QidSet -> TermList .

  eq smtConst2smtVar(C) = qid(string(getName(C)) + ":" + string(getType(C))) .
  eq constants2variables(V, SP) = V .
  eq constants2variables(C, SP)
   = if C in SP
		then smtConst2smtVar(C)
        else C fi . 
  eq constants2variables(F[TL], SP) = F[constants2variables*(TL, SP)] .
  eq constants2variables*(T, SP) = constants2variables(T, SP) .
  eq constants2variables*((T,TL), SP) = constants2variables(T, SP), constants2variables*(TL, SP) [owise] .
  
  eq smtVar2smtConst(V) = qid(string(getName(V)) + "." + string(getType(V))) .
  eq variables2constants(C, SP) = C .
  eq variables2constants(V, SP)
   = if V in SP
		then smtVar2smtConst(V)
        else V fi . 
  eq variables2constants(F[TL], SP) = F[variables2constants*(TL, SP)] .
  eq variables2constants*(T, SP) = variables2constants(T, SP) .
  eq variables2constants*((T,TL), SP) = variables2constants(T, SP), variables2constants*(TL, SP) [owise] .
  
  op MaudeSort2SmtSort : Term -> Term .
  op MaudeSort2SmtSort* : Term -> Term .
  op MaudeSort2SmtSortPos : String -> String .
  op MaudeSort2SmtSortVar : String Type -> Variable .
  op MaudeSort2SmtSortConst : String Type -> Constant .
  op MaudeSortTL2SmtSortTL : TermList -> TermList .
  op MaudeSortACU2SmtSort : Qid TermList -> Term .
  eq MaudeSort2SmtSort(V) = MaudeSort2SmtSortVar(string(getName(V)), getType(V)) .
  eq MaudeSort2SmtSort('0.Zero) = '0.Integer .
  eq MaudeSort2SmtSort('s_['0.Zero]) = '1.Integer .
  eq MaudeSort2SmtSort(T) = MaudeSort2SmtSort*(T) [owise] .
  eq MaudeSort2SmtSort*(C) =  MaudeSort2SmtSortConst(string(getName(C)), getType(C)) .
  eq MaudeSort2SmtSort*(F['0.Zero]) = qid(MaudeSort2SmtSortPos(string(F)) + ".Integer") .
  eq MaudeSort2SmtSort*('-[F['0.Zero]]) = qid("-" + MaudeSort2SmtSortPos(string(F)) + ".Integer") .
  eq MaudeSort2SmtSort*('_+_[TL]) = MaudeSortACU2SmtSort('_+_, TL) .
  eq MaudeSort2SmtSort*('_*_[TL]) = MaudeSortACU2SmtSort('_*_, TL) .
  eq MaudeSort2SmtSort*(F[TL]) = F[MaudeSortTL2SmtSortTL(TL)] [owise] .
  eq MaudeSort2SmtSortPos(S) = substr(S, 3, length(S)) .
  eq MaudeSort2SmtSortConst(S, 'Bool) = qid(S + ".Boolean") .
  eq MaudeSort2SmtSortConst(S, 'Int) = qid(S + ".Integer") .
  eq MaudeSort2SmtSortVar(S, 'Bool) = qid(S + ":Boolean") .
  eq MaudeSort2SmtSortVar(S, 'Int) = qid(S + ":Integer") .
  eq MaudeSortTL2SmtSortTL(empty) = empty .
  eq MaudeSortTL2SmtSortTL((T, TL)) = MaudeSort2SmtSort(T), MaudeSortTL2SmtSortTL(TL) [owise] .
  eq MaudeSortACU2SmtSort(F, T)
   = MaudeSort2SmtSort(T) .
  eq MaudeSortACU2SmtSort(F, (T, TL))
   = F[MaudeSort2SmtSort(T), MaudeSortACU2SmtSort(F, TL)] [owise] .
  
  op getCondVars : SmtCondi TermList TermList -> TermList .
  eq getCondVars(not SC, OVL, TL) = getCondVars(SC, OVL, TL) .
  eq getCondVars(SC and SC', OVL, TL) = getCondVars(SC', OVL, getCondVars(SC, OVL, TL)) .
  eq getCondVars(SC xor SC', OVL, TL) = getCondVars(SC', OVL, getCondVars(SC, OVL, TL)) .
  eq getCondVars(SC or SC', OVL, TL) = getCondVars(SC', OVL, getCondVars(SC, OVL, TL)) .
  eq getCondVars(SC implies SC', OVL, TL) = getCondVars(SC', OVL, getCondVars(SC, OVL, TL)) .
  eq getCondVars(SC === SC', OVL, TL) = getCondVars(SC', OVL, getCondVars(SC, OVL, TL)) .
  eq getCondVars(SC =/== SC', OVL, TL) = getCondVars(SC', OVL, getCondVars(SC, OVL, TL)) .

  eq getCondVars(ST1 === ST2, OVL, TL) = getCondVars(ST2, OVL, getCondVars(ST1, OVL, TL)) .
  eq getCondVars(ST1 =/== ST2, OVL, TL) = getCondVars(ST2, OVL, getCondVars(ST1, OVL, TL)) .
  eq getCondVars(ST1 < ST2, OVL, TL) = getCondVars(ST2, OVL, getCondVars(ST1, OVL, TL)) .
  eq getCondVars(ST1 <= ST2, OVL, TL) = getCondVars(ST2, OVL, getCondVars(ST1, OVL, TL)) .
  eq getCondVars(ST1 > ST2, OVL, TL) = getCondVars(ST2, OVL, getCondVars(ST1, OVL, TL)) .
  eq getCondVars(ST1 >= ST2, OVL, TL) = getCondVars(ST2, OVL, getCondVars(ST1, OVL, TL)) .
  eq getCondVars(ST1 divisible ST2, OVL, TL) = getCondVars(ST2, OVL, getCondVars(ST1, OVL, TL)) .
  eq getCondVars(isInteger(ST), OVL, TL) = getCondVars(ST, OVL, TL) .

  eq getCondVars(-I ST, OVL, TL) = getCondVars(ST, OVL, TL) .
  eq getCondVars(-R ST, OVL, TL) = getCondVars(ST, OVL, TL) .
  eq getCondVars(ST1 +I ST2, OVL, TL) = getCondVars(ST2, OVL, getCondVars(ST1, OVL, TL)) .
  eq getCondVars(ST1 +R ST2, OVL, TL) = getCondVars(ST2, OVL, getCondVars(ST1, OVL, TL)) .
  eq getCondVars(ST1 -I ST2, OVL, TL) = getCondVars(ST2, OVL, getCondVars(ST1, OVL, TL)) .
  eq getCondVars(ST1 -R ST2, OVL, TL) = getCondVars(ST2, OVL, getCondVars(ST1, OVL, TL)) .
  eq getCondVars(ST1 *I ST2, OVL, TL) = getCondVars(ST2, OVL, getCondVars(ST1, OVL, TL)) .
  eq getCondVars(ST1 *R ST2, OVL, TL) = getCondVars(ST2, OVL, getCondVars(ST1, OVL, TL)) .
  eq getCondVars(ST1 div ST2, OVL, TL) = getCondVars(ST2, OVL, getCondVars(ST1, OVL, TL)) .
  eq getCondVars(ST1 mod ST2, OVL, TL) = getCondVars(ST2, OVL, getCondVars(ST1, OVL, TL)) .
  eq getCondVars(ST1 / ST2, OVL, TL) = getCondVars(ST2, OVL, getCondVars(ST1, OVL, TL)) .
  eq getCondVars(toReal(ST), OVL, TL) = getCondVars(ST, OVL, TL) .
  eq getCondVars(toInteger(ST), OVL, TL) = getCondVars(ST, OVL, TL) .
  eq getCondVars(C, OVL, TL) = TL .
  eq getCondVars(V, (OVL, V, OVL'), TL)  *** variables from the original problem don't get renamed
   = TL .
  eq getCondVars(V, OVL, (TL, V, TL'))
   = TL, V, TL' .
  eq getCondVars(V, OVL, TL)
   = TL, V [owise] .

***  op _vINsc_ : Variable SmtCondi -> Bool .
***
***  eq V vINsc (not SC) = V in SC .
***  eq V vINsc (SC and SC') = V in SC or-else V in SC' .
***  eq V vINsc (SC xor SC') = V in SC or-else V in SC' .
***  eq V vINsc (SC or SC') = V in SC or-else V in SC' .
***  eq V vINsc (SC implies SC') = V in SC or-else V in SC' .
***  eq V vINsc (SC === SC') = V in SC or-else V in SC' .
***  eq V vINsc (SC =/== SC') = V in SC or-else V in SC' .
***  eq V vINsc (SC === SC') = V in SC or-else V in SC' .
***  eq V vINsc (SC =/== SC') = V in SC or-else V in SC' .
***  eq V vINsc (ST1 === ST2) = V in ST1 or-else V in ST2 .
***  eq V vINsc (ST1 =/== ST2) = V in ST1 or-else V in ST2 .
***  eq V vINsc (ST1 < ST2) = V in ST1 or-else V in ST2 .
***  eq V vINsc (ST1 <= ST2) = V in ST1 or-else V in ST2 .
***  eq V vINsc (ST1 > ST2) = V in ST1 or-else V in ST2 .
***  eq V vINsc (ST1 >= ST2) = V in ST1 or-else V in ST2 .
***  eq V vINsc (ST1 divisible ST2) = V in ST1 or-else V in ST2 .
***  eq V vINsc isInteger(ST) = V in ST .
***  eq V vINsc (-I ST) = V in ST .
***  eq V vINsc (-R ST) = V in ST .
***  eq V vINsc (ST1 +I ST2) = V in ST1 or-else V in ST2 .
***  eq V vINsc (ST1 +R ST2) = V in ST1 or-else V in ST2 .
***  eq V vINsc (ST1 -I ST2) = V in ST1 or-else V in ST2 .
***  eq V vINsc (ST1 -R ST2) = V in ST1 or-else V in ST2 .
***  eq V vINsc (ST1 *I ST2) = V in ST1 or-else V in ST2 .
***  eq V vINsc (ST1 *R ST2) = V in ST1 or-else V in ST2 .
***  eq V vINsc (ST1 div ST2) = V in ST1 or-else V in ST2 .
***  eq V vINsc (ST1 mod ST2) = V in ST1 or-else V in ST2 .
***  eq V vINsc (ST1 / ST2) = V in ST1 or-else V in ST2 .
***  eq V vINsc toReal(ST) = V in ST .
***  eq V vINsc toInteger(ST) = V in ST .
***  eq V vINsc C = false .
***  eq V vINsc V = true .
***  eq V vINsc V' = false [owise] .
    
endfm
