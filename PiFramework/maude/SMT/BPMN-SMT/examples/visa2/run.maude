---- Symbolic Formal Modelling and Analysis of BPMN using Maude+CVC4
---- authors: Francisco Duran, Gwen Salaun, Camilo Rocha
---- file: verif.maude
----
---- This file contains operations for the automated symbolic analysis
---- of BPMN processes

load ../../verif.maude
load visa.maude

red in STRING : "visa.maude" .

mod RUN is
  pr VERIF .
  pr BPMN-EX .

  var  Atts      : AttributeSet .
  var  B         : Boolean .
  var  C         : Cid .
  vars Cnf St    : Configuration .
  var  VI        : Map{SymbVar,Nat} .
  var  O PId SId : Oid .
  var  Tks       : Set{Message} .
  var  Id        : Id .
  var  NId       : NId .
  var  FId1 FId2 : FId .
  var  Str       : String .
  var  T         : Time .
  var  Nodes     : Set{Node} .

  op get-constr : Configuration -> Boolean .
  op get-varidx : Configuration -> Map{SymbVar,Nat} .
  op get-tokens : Configuration -> Set{Message} .
  eq get-constr( < O : C | Atts, constr : B > Cnf)
   = B .
  eq get-varidx( < O : C | Atts, varidx : VI > Cnf)
   = VI .
  eq get-tokens( < O : C | Atts, tokens : Tks > Cnf)
   = Tks .

  op token-at : Id Configuration -> Bool .
  eq token-at(Id, < O : Simulation | tokens : (token(Id, 0) Tks), Atts > Cnf)
    = true .
  eq token-at(Id, Cnf) = false [owise] .

  op token-at : String Configuration -> Bool .
  eq token-at(Str, < SId : Simulation | tokens : (token(NId, 0) Tks), Atts >
                   < PId : Process | nodes : (task(NId, Str, FId1, FId2, T), Nodes), Atts >)
    = true .
  eq token-at(Str, Cnf) = false [owise] .

  vars OK        : Boolean .
  vars TRY FSIZE : Integer .
  vars QUAL      : Real .


  pr META-LEVEL .
  pr INTEGER .
  pr CONVERSION .
  op gen-intvar : String -> Integer .
  op error-int : -> [Integer] .
  var S : String .

  eq gen-intvar(S)
   = downTerm(qid(S + ":Integer"), error-int) .
endm

----eof

rew [10] initSystem(v(OK:Boolean) v(TRY:Integer) v(FSIZE:Integer) v(QUAL:Real)) .
---(
rewrite [10] in RUN : initSystem(v(OK) v(TRY) v(FSIZE) v(QUAL)) .
rewrites: 162 in 4ms cpu (4ms real) (38306 rewrites/second)
result Configuration:
  < p : Process | nodes : ..., flows : ... >
  < s : Simulation |
    tokens : token(sf8, 0),
    gtime : 0,
    constr : (TRY#1:Integer === (0).Integer and
              FSIZE#1:Integer >= (2).Integer and
              TRY#2:Integer === TRY#1:Integer + (1).Integer),
    varidx : (v(OK) |-> 0, v(TRY) |-> 2, v(FSIZE) |-> 1, v(QUAL) |-> 0) >
---)

---- first example in the paper ... note the hack in the condition of the search command
search [10] initSystem(v(OK) v(TRY) v(FSIZE) v(QUAL))
       =>! St
       such that check-sat(get-constr(St) and process-expression(get-varidx(St), gen-intvar("TRY") === 3)) .
---(
Solution 1 (state 155)
states: 171  rewrites: 2111 in 68ms cpu (70ms real) (30874 rewrites/second)
St --> < p : Process | nodes : ..., flows : ... >
       < s : Simulation |
         tokens : empty,
         gtime : 0,
         constr : (TRY#1:Integer === (0).Integer and
                   FSIZE#1:Integer >= (2).Integer and
                   TRY#2:Integer === TRY#1:Integer + (1).Integer and
                   FSIZE#2:Integer >= (2).Integer and
                   TRY#3:Integer === TRY#2:Integer + (1).Integer and
                   FSIZE#3:Integer < (2).Integer and
                   QUAL#1:Real < (9/10).Real and
                   TRY#4:Integer === TRY#3:Integer + (1).Integer and
                   TRY#4:Integer === (3).Integer),
         varidx : (v(OK) |-> 0, v(TRY) |-> 4, v(FSIZE) |-> 3, v(QUAL) |-> 1) >
---)


---- second example in the paper
search [1,500] initSystem(v(OK) v(TRY) v(FSIZE) v(QUAL)) =>! St such that get-tokens(St) =/= empty .
---(
Solution 1 (state 249)
states: 265  rewrites: 2852 in 97ms cpu (99ms real) (29183 rewrites/second)
St --> < p : Process | nodes : ..., flows : ... >
       < s : Simulation |
         tokens : token(sf12, 0),
         gtime : 0,
         constr : (TRY#1:Integer === (0).Integer and
                   FSIZE#1:Integer >= (2).Integer and
                   TRY#2:Integer === TRY#1:Integer + (1).Integer and
                   FSIZE#2:Integer >= (2).Integer and
                   TRY#3:Integer === TRY#2:Integer + (1).Integer and
                   FSIZE#3:Integer >= (2).Integer and
                   TRY#4:Integer === TRY#3:Integer + (1).Integer and
                   FSIZE#4:Integer < (2).Integer and
                   QUAL#1:Real < (9/10).Real and
                   TRY#5:Integer === TRY#4:Integer + (1).Integer),
         varidx : (v(OK) |-> 0, v(TRY) |-> 5, v(FSIZE) |-> 4, v(QUAL) |-> 1) >
---)

---- task(t8, "Pay for fees", sf17, sf18, 0),
search [1,500] initSystem(v(OK) v(TRY) v(FSIZE) v(QUAL))
       =>! St
       such that token-at("Pay for fees", St)
             and check-sat(get-constr(St) and process-expression(get-varidx(St), gen-intvar("FSIZE") > 2)) .
---(
No solution.
states: 8846  rewrites: 117728 in 7818ms cpu (8151ms real) (15057 rewrites/second)
)

search [1,500] initSystem(v(OK) v(TRY) v(FSIZE) v(QUAL))
       =>! St
       such that token-at(t8, St)
             and check-sat(get-constr(St) and process-expression(get-varidx(St), gen-intvar("FSIZE") > 2)) .
---(
No solution.
states: 8846  rewrites: 108430 in 8378ms cpu (8766ms real) (12941 rewrites/second)
---)
