---- Symbolic Formal Modelling and Analysis of BPMN using Maude+CVC4/Yices2
----
---- authors: Francisco Duran, Gwen Salaun, Camilo Rocha
----
---- file: bpmn.maude
----
---- This file contains the definitions for the symbolic
---- representation of the BPMN process and the rules describing the
---- symbolic BPMN behavioral semantics.
----
---- Changes:
---- 01/15/2018: added support for look ups
---- - look ups and assigmants are operations of type Update (assignments had their onw sort Assignment)
---- - prepare-updates is now call prepare-update and handles both
---- 11/29/2017: added support for assignments

load my-real-time-maude.maude
load 2-tuple.maude
load smt.maude
load smt-util.maude

fmod ID is
  sorts SId PId NId FId Id .
  subsorts SId PId NId FId < Id .
endfm

view NId from TRIV to ID is
  sort Elt to NId .
endv

view FId from TRIV to ID is
  sort Elt to FId .
endv

view PId from TRIV to ID is
  sort Elt to PId .
endv

view SId from TRIV to ID is
  sort Elt to SId .
endv

view Id from TRIV to ID is
  sort Elt to Id .
endv

view Set`{FId`} from TRIV to SET{FId} is
  sort Elt to Set{FId} .
endv

fmod IDLIST is
  pr ID .
  sort IdList .
  subsort Id < IdList .
  op mtl    : -> IdList [ctor] .
  op _:_    : IdList IdList -> IdList [ctor assoc id: mtl] .
endfm

fmod IDLISTLIST is
  pr IDLIST .
  sort IdListList .
  subsort IdList < IdListList .
  op mtll : -> IdListList [ctor] .
  op _._   : IdListList IdListList -> IdListList [ctor assoc id: mtll] .

  op gen : IdList -> IdListList [memo] .  ----c Generate all possible non-empty sublists of a list
  op ins : IdListList Id -> IdListList .  ----c Insert an identifier in a list of identifiers
  vars ID ID1 ID2 : Id .
  vars IL IL1 IL2 : IdList .
  vars ILL ILL1 ILL2 : IdListList .

  eq gen(mtl)
   = mtll .
  eq gen(ID1 : IL1)
   = gen(IL1) . ins(gen(IL1), ID1) .
  eq ins(mtll, ID1)
   = ID1 .
  eq ins(IL1 . ILL1, ID1)
   = ((ID1 : IL1) . ins(ILL1, ID1)) .
endfm

--------------------------
---- Symbolic updates ----
--------------------------
fmod SYMBOLIC-UPDATES is
  pr SMT-UTIL .
  sorts SymbUpdate .

  op _:=_ : Boolean Boolean -> SymbUpdate [ctor] .
  op _:=_ : Integer Integer -> SymbUpdate [ctor] .
  op _:=_ : Real Real -> SymbUpdate [ctor] .

  op lookup : Boolean -> SymbUpdate [ctor] .
  op lookup : Integer -> SymbUpdate [ctor] .
  op lookup : Real -> SymbUpdate [ctor] .
endfm

fmod SYMBOLIC-VARIABLE is
  pr SMT-UTIL .
  sort SymbVar .
  op v : Boolean -> SymbVar [ctor] .
  op v : Integer -> SymbVar [ctor] .
  op v : Real -> SymbVar [ctor] .
endfm

view Boolean from TRIV to BOOLEAN is
  sort Elt to Boolean .
endv

view Integer from TRIV to INTEGER is
  sort Elt to Integer .
endv

view Real from TRIV to REAL is
  sort Elt to Real .
endv

view Tuple`{Id`,Boolean`} from TRIV to 2-TUPLE{Id, Boolean} is
  sort Elt to Tuple{Id, Boolean} .
endv

view SymbUpdate from TRIV to SYMBOLIC-UPDATES is
  sort Elt to SymbUpdate .
endv

view Configuration from TRIV to CONFIGURATION is
  sort Elt to Configuration .
endv

view SymbVar from TRIV to SYMBOLIC-VARIABLE is
  sort Elt to SymbVar .
endv

------------------
---- Gateways ----
------------------
fmod GATEWAY is
  sorts Gateway SymbGateway NonSymbGateway .
  subsort SymbGateway NonSymbGateway < Gateway .
  op exclusive : -> SymbGateway [ctor] .
  op inclusive : -> SymbGateway [ctor] .
  op parallel : -> NonSymbGateway [ctor] .
endfm

---------------
---- Nodes ----
---------------
fmod NODE is
  pr ID .
  pr STRING .
  pr GATEWAY .
  pr SET{FId} .
  pr LIST{FId} .
  pr LIST{Tuple`{Id`,Boolean`}} .
  pr LIST{SymbUpdate} .
  pr POSRAT-TIME-DOMAIN-WITH-INF .

  sort Node .
  op start : NId FId -> Node [ctor] .
  op end : NId FId -> Node [ctor] . ---- TODO: just one input flow??
  op task : NId String FId FId Time -> Node [ctor] . ---- description of the task
  op task : NId String FId FId Time List{SymbUpdate}-> Node [ctor] . ---- description of the task with list of symbolic updates
  op merge : NId Gateway Set{FId} FId -> Node [ctor] . ---- a set of input flows, an output flow

  ---- symbolic split gateways
  op split : NId SymbGateway FId List{Tuple`{Id`,Boolean`}} -> Node [ctor] . ---- an input flow, a list of pairs output flow - constraint
  op split : NId NonSymbGateway FId Set{FId} -> Node [ctor] . ---- an input flow, a set of output flows

  eq task(N:NId, S:String, F:FId, G:FId, T:Time)
   = task(N:NId, S:String, F:FId, G:FId, T:Time, (nil).List{SymbUpdate}) .
endfm

view Node from TRIV to NODE is
  sort Elt to Node .
endv

---------------
---- Flows ----
---------------
fmod FLOW is
  pr ID .
  pr NAT-TIME-DOMAIN-WITH-INF .

  sort Flow .
  op flow : FId Time -> Flow [ctor] .
endfm

view Flow from TRIV to FLOW is
  sort Elt to Flow .
endv

-----------------
---- Message ----
-----------------
mod MESSAGE is
  pr ID .
  pr CONFIGURATION .
  pr NAT-TIME-DOMAIN-WITH-INF .

  sort Message .
  subsort Message < Configuration .

  op init : -> Message [ctor] .
  op token : Id Time -> Message [ctor] .
endm

view Message from TRIV to MESSAGE is
  sort Elt to Message .
endv

view Set`{Message`} from TRIV to SET{Message} is
  sort Elt to Set`{Message`} .
endv

view Map`{SymbVar`,Nat`} from TRIV to MAP{SymbVar,Nat} is
  sort Elt to Map`{SymbVar`,Nat`} .
endv

----------------------------------------------------
---- Description of the BPMN symbolic semantics ----
----------------------------------------------------
mod BPMN-SEM is
  pr SET{Node} .
  pr SET{Flow} .
  pr SET{Message} .
  pr LIST{SymbUpdate} .
  pr CONFIGURATION .
  pr IDLISTLIST .
  pr MAP{SymbVar,Nat} .
  pr 2-TUPLE{Map`{SymbVar`,Nat`},Boolean} .
  pr SMT-UTIL .
  pr LIST{SymbVar} .

  subsort SId PId < Oid < Id . ---- PIds are valid object ids

  vars PId : PId .
  vars SId : SId .
  vars FId FId1 FId2 : FId .
  vars NId : NId .
  vars Nodes : Set{Node} .
  vars F Flows : Set{Flow} .
  vars Atts Atts1 Atts2 : AttributeSet .
  vars Conf : Configuration .
  vars TaskName : String .
  vars FIds FIds1 FIds2 Visited : Set{FId} .
  vars LTIB LTIB1 LTIB2 : List{Tuple`{Id`,Boolean`}} .
  vars T T1 T2 : Time .
  vars GW : Gateway .
  vars Tks Tks' : Set{Message} .
  vars Tk : Message .
  vars N : Nat .
  vars Id : Id .
  vars B B1 B2  : Boolean .
  vars LFId LFId1 LFId2 : List{FId} .
  vars IL IL1 IL2 : IdList .
  vars ILL ILL1 ILL2 : IdListList .
  vars AsgL AsgL1 AsgL2 : List{SymbUpdate} .
  vars VMp VMp1 VMp2 : Map{SymbVar,Nat} .
  vars I I1 I2 : Integer .
  vars R R1 R2 : Real .

  ---- Process ----
  ---- class Process | nodes : Set{Node}, flows : Set{Flow} .
  sort Process .
  subsort Process < Cid .

  op Process : -> Process [ctor] .
  op nodes :_ : Set{Node} -> Attribute [ctor] .
  op flows :_ : Set{Flow} -> Attribute [ctor] .

  ---- Simulation ----
  ---- class Simulation | tokens : Set{Message}, gtime : Time, constr : Boolean .
  sort Simulation .
  subsort Simulation < Cid .

  op Simulation : -> Simulation [ctor] .
  op tokens :_ : Set{Message} -> Attribute [ctor] .
  op gtime  :_ : Time -> Attribute [ctor] .
  op constr :_ : Boolean -> Attribute [ctor] .
  op varidx :_ : Map{SymbVar,Nat} -> Attribute [ctor] .

  ------------------------------------------------------------------------------
  ---- Global time - tick
  ---- Note: we do not force to execute "actions" as soon as possible with this
  ----  time semantics, because the time can go on when there are timers to zero.

  ----  see tick rule in verif.maude

  op mte : Set{Node} Set{Message} -> Time .
  op mte : Set{Node} Set{Message} Set{Message} -> Time .
  op delta : Set{Message} Time -> Set{Message} .
  op maxTokenTimePar : Set{FId} Set{Message} Time -> Time .
  op maxTokenTimeInc : Set{FId} Set{Node} Set{Message} Set{Message} Time -> Time .

  eq mte(Nodes, Tks) = mte(Nodes, Tks, Tks) .
  --- for a parallel merge we take the max of the incoming tokens, infinity if someone is missing
  eq mte((merge(NId, parallel, (FId1, FIds), FId2), Nodes), (token(FId1, T), Tks), Tks')
    = min(maxTokenTimePar(FIds, Tks, T),
          mte((merge(NId, parallel, (FId1, FIds), FId2), Nodes), Tks, Tks')) .
  --- for an exclusive merge the activation of a flow is enough
  eq mte((merge(NId, exclusive, (FId1, FIds), FId2), Nodes), (token(FId1, T), Tks), Tks')
    = min(T, mte((merge(NId, exclusive, (FId1, FIds), FId2), Nodes), Tks, Tks')) .
  --- for the inclusive merge we take the max time of the tokens already in the incoming flows,
  --- if there were pending tokens the merge wouldn't be applied, but there would be
  --- something to happen elsewhere
  eq mte((merge(NId, inclusive, (FId1, FIds), FId2), Nodes), (token(FId1, T), Tks), Tks')
    = min(maxTokenTimeInc(FIds, (merge(NId, inclusive, (FId1, FIds), FId2), Nodes), Tks, Tks', T),
          mte((merge(NId, inclusive, (FId1, FIds), FId2), Nodes),
              removeTokensInclusive(FIds, Tks), Tks')) .
  eq mte(Nodes, (token(Id, T), Tks), Tks') = min(T, mte(Nodes, Tks, Tks')) [owise] .
  eq mte(Nodes, empty, Tks) = INF .

  --- removes all token consumed when the inclusive merge is triggered
  op removeTokensInclusive : Set{FId} Set{Message} -> Set{Message} .
  --- all the branches have been treated
  eq removeTokensInclusive(empty, Tks) = Tks .
  --- there is a token for that flow, we remove it
  eq removeTokensInclusive((FId, FIds), (token(FId, 0), Tks))
    = removeTokensInclusive(FIds, Tks) .
  --- there is no token to remove for this flow
  eq removeTokensInclusive(FIds, Tks) = Tks [owise] .

  eq maxTokenTimePar((FId, FIds), (token(FId, T1), Tks), T2)
    = if T1 > T2
      then maxTokenTimePar(FIds, Tks, T1)
      else maxTokenTimePar(FIds, Tks, T2)
      fi .
  eq maxTokenTimePar((FId, FIds), Tks, T) = INF [owise] .
  eq maxTokenTimePar(empty, Tks, T) = T .

  eq maxTokenTimeInc((FId, FIds), Nodes, (token(FId, T1), Tks), Tks', T2)
    = if T1 > T2
      then maxTokenTimeInc(FIds, Nodes, Tks, Tks', T1)
      else maxTokenTimeInc(FIds, Nodes, Tks, Tks', T2)
      fi .
  eq maxTokenTimeInc((FId, FIds), Nodes, Tks, Tks', T)
    = if expectingToken(FId, Nodes, Tks', FId)
      then INF
      else maxTokenTimeInc(FIds, Nodes, Tks, Tks', T)
      fi
    [owise] .
  eq maxTokenTimeInc(empty, Nodes, Tks, Tks', T) = T .

  ---- checks if a given flow has an upstream token in the process
  ---- strategy: we move backward and check if every encountered flow has a corresponding token
  op expectingToken : FId Set{Node} Set{Message} Set{FId} -> Bool .
  --- checks if there at least one token in a set of flows
  op expectingOneToken : Set{FId} Set{Node} Set{Message} Set{FId} -> Bool .
  --- token but time > 0
  eq expectingToken(FId, Nodes, (token(FId, T), Tks), Visited) = true  .
  --- start event
  eq expectingToken(FId, (start(NId, FId), Nodes), (token(NId, T), Tks), Visited) ---- init ?
    = true .

  --- task
  ceq expectingToken(FId, (task(NId, TaskName, FId1, FId, T, AsgL), Nodes), Tks, Visited)
    = isToken(NId, Tks)
      or-else
      expectingToken(FId1, (task(NId, TaskName, FId1, FId, T, AsgL), Nodes), Tks, (FId1, Visited))
    if not(isInFIds(FId1, Visited)) .
  eq expectingToken(FId, (task(NId, TaskName, FId1, FId, T, AsgL), Nodes), Tks, Visited) = false [owise] .

  --- split
  --- for any split, we move to backwards search a token
  ceq expectingToken(FId, (split(NId, GW, FId1, (LTIB1 (FId,B) LTIB2)), Nodes), Tks, Visited)
    = expectingToken(FId1, (split(NId, GW, FId1, (LTIB1 (FId,B) LTIB2)), Nodes), Tks, (FId1, Visited))
    if not(isInFIds(FId1, Visited)) .
  eq expectingToken(FId, (split(NId, GW, FId1, (LTIB1 (FId,B) LTIB2)), Nodes), Tks, Visited)
   = false [owise] .

  --- merge
  --- for any kind of merge gateway, we look for at least one token in one branch
  eq expectingToken(FId, (merge(NId, GW, FIds, FId), Nodes), Tks, Visited)
    = expectingOneToken(FIds, (merge(NId, GW, FIds, FId), Nodes), Tks, Visited) .
  eq expectingToken(FId, Nodes, Tks, Visited) = false [owise] .

  --- checks is there is at least one token given a set of flows upstream to a merge
  eq expectingOneToken(empty, Nodes, Tks, Visited) = false .
  ceq expectingOneToken((FId, FIds), Nodes, Tks, Visited)
    = expectingToken(FId, Nodes, Tks, (FId, Visited))
      or-else
      expectingOneToken(FIds, Nodes, Tks, Visited)
    if not(isInFIds(FId, Visited)) .
  eq expectingOneToken((FId, FIds), Nodes, Tks, Visited) = false [owise] .

  ---- for each branch, checks if there is a token and
  ---- if there is no token available, checks that we should not wait for one (backward traversal)
  op allTokensInclusive : Set{FId} Set{Message} Set{Node} -> Bool .
  --- checks if a given token is present in the set of messages (any FlowStamp)
  op isToken : Id Set{Message} -> Bool .
  --- checks if a FId is in a set of FId
  op isInFIds : FId Set{FId} -> Bool [memo] .

  eq allTokensInclusive(empty, Tks, Nodes) = true .   --- all the branches have been treated
  eq allTokensInclusive((FId, FIds), (token(FId, 0), Tks), Nodes)   --- there is a token for that branch
    = allTokensInclusive(FIds, (token(FId, 0), Tks), Nodes) .       --- we check for the other branches
  ceq allTokensInclusive((FId, FIds), Tks, Nodes)     --- there is no token at 0 and we do not expect one
    =  allTokensInclusive(FIds, Tks, Nodes)
    if not(expectingToken(FId, Nodes, Tks, (FId))) .
  eq allTokensInclusive(FIds, Tks, Nodes) = false [owise] .    --- there is no token at 0 and we expect one

  --- generates a token in the configuration for all outgoing flows
  op generateTokensSplitParallel : Set{FId} Set{Flow} -> Set{Message} .
  eq generateTokensSplitParallel(empty, Flows) = empty .
  eq generateTokensSplitParallel((FId, FIds), (flow(FId, T), Flows))
    = (token(FId, T),
       generateTokensSplitParallel(FIds, Flows)) .

  ---- a given token is in the set of tokens ?
  eq isToken(Id, (token(Id, T), Tks)) = true .
  eq isToken(Id, Tks) = false [owise] .

  --- checks if a FId is in a set of FId
  eq isInFIds(FId, empty) = false .
  eq isInFIds(FId, (FId2, FIds))
    = (FId == FId2) or-else isInFIds(FId, FIds) .

  eq delta(empty, T) = empty .
  eq delta((token(Id, T1), Tks), T2)
    = if (T1 > T2)
      then (token(Id, sd(T1, T2)), delta(Tks, T2))
      else (token(Id, 0), delta(Tks, T2))
      fi .

  ---- checks if there is a token for all incoming flows
  op allTokensParallel : Set{FId} Set{Message} -> Bool .
  eq allTokensParallel((FId, FIds), (token(FId, 0), Tks))
    = allTokensParallel(FIds, Tks) .
  eq allTokensParallel(empty, Tks) = true .
  eq allTokensParallel(FIds, Tks) = false [owise] .

  ---- removes all the incoming tokens
  op removeTokensParallel : Set{FId} Set{Message} -> Set{Message} .
  eq removeTokensParallel((FId, FIds), (token(FId, 0), Tks))
    = (removeTokensParallel(FIds, Tks)) .
  eq removeTokensParallel(empty, Tks) = Tks .

  -------------------------------------------------
  ---- Auxiliary functions for inclusive split ----
  -------------------------------------------------

  ---- first component projection of a list of tuples (id,constr)
  op project1 : List{Tuple`{Id`,Boolean`}} -> IdList [memo] .
  eq project1(nil)
   = mtl .
  eq project1((FId,B) LTIB )
   = FId : project1(LTIB) .

  ---- computes a constraint given a list of flow identifiers and a list of
  ---- tuples (id,constr)
  op  get-constr : IdList List{Tuple`{Id`,Boolean`}} -> Boolean [memo] .
  op $get-constr : IdList List{Tuple`{Id`,Boolean`}} Boolean -> Boolean [memo] .
  eq get-constr(IL, LTIB)
   = $get-constr(IL, LTIB, true) .
  eq $get-constr(mtl, nil, B)
   = B .
  eq $get-constr((FId : IL), (LTIB1 (FId, B1) LTIB2), B)
   = $get-constr(IL, LTIB1 LTIB2, B and B1) .
  eq $get-constr(mtl, LTIB1 (FId, B1), B)
   = $get-constr(mtl, LTIB1, B and not(B1)) .

  ----c eq get-constr(mtl, LTIB)
  ----c  = $get-constr(mtl, nil,
  ----c  = (true).Boolean .
  ----c eq get-constr((FId : IL), (LTIB1 (FId, B) LTIB2))
  ----c  = B and get-constr(IL, (LTIB1 (FId, B) LTIB2)) .

  ---- sets the time for the given list of flow identifiers w.r.t. to
  ---- the given token information
  op set-time : IdList Set{Flow} -> Set{Message} [memo] .
  eq set-time(mtl, Flows)
   = empty .
  eq set-time( FId : IL, (flow(FId, T), Flows) )
   = token(FId, T) , set-time(IL, (flow(FId, T), Flows)) .

  -----------------------------------
  ---- Initiation of the process ----
  -----------------------------------
  rl [startProc] :
     < PId : Process |
           nodes : (start(NId, FId), Nodes),
           flows : (flow(FId, T), Flows),
           Atts >
     < SId : Simulation |
           tokens : (token(NId, 0), Tks),
           Atts1 >
  => < PId : Process |
           nodes : (start(NId, FId), Nodes),
           flows : (flow(FId, T), Flows),
           Atts >
     < SId : Simulation |
           tokens : (token(FId, T), Tks),
           Atts1 >
     [print "startProc " PId] .

  ------------------------------------
  ---- Termination of the process ----
  ------------------------------------
  rl [endProc] :
     < PId : Process |
           nodes : (end(NId, FId), Nodes),
           Atts >
     < SId : Simulation |
           tokens : (token(FId, 0), Tks),
           Atts1 >
  => < PId : Process |
           nodes : (end(NId, FId), Nodes),
           Atts >
     < SId : Simulation |
           tokens : Tks,
           Atts1 >
     [print "endProc " PId] .

  ------------------------------
  ---- Initiation of a task ----
  ------------------------------
  rl [initTask] :
     < PId : Process |
           nodes : (task(NId, TaskName, FId1, FId2, T, AsgL), Nodes),
           flows : Flows,
           Atts >
     < SId : Simulation |
           tokens : (token(FId1, 0), Tks),
           Atts1 >
  => < PId : Process |
           nodes : (task(NId, TaskName, FId1, FId2, T, AsgL), Nodes),
           flows : Flows,
           Atts >
     < SId : Simulation |
           tokens : (token(NId, T), Tks),
           Atts1 >
     [print "taskInit " TaskName] .

  ------------------------------------------
  ---- Execution / completion of a task ----
  ------------------------------------------
 crl [execTask] :
     < PId : Process |
           nodes : (task(NId, TaskName, FId1, FId2, T, AsgL), Nodes),
           flows : (flow(FId2, T2), Flows),
           Atts >
     < SId : Simulation |
           tokens : (token(NId, 0), Tks),
           constr : B,
           varidx : VMp,
           Atts1 >
  => < PId : Process |
           nodes : (task(NId, TaskName, FId1, FId2, T, AsgL), Nodes),
           flows : (flow(FId2, T2), Flows),
           Atts >
     < SId : Simulation |
           tokens : (token(FId2, T2), Tks),
           constr : (B and B1),
           varidx : VMp1,
           Atts1 >
  if (VMp1, B1) := prepare-updates(AsgL, VMp)
  /\ check-sat(B and B1)
     [print "TASK COMPLETION ===>>> " TaskName] .

  ---- Auxiliary functions for implementing updates (assignments and lookups)
  ----
  ---- Prepares a list of updates w.r.t. a given map of variable
  ---- indices.  It returns the resulting map (from variable
  ---- renaiming) and the constraint representing the assignments.
  op  prepare-updates : List{SymbUpdate} Map{SymbVar,Nat} -> Tuple{Map`{SymbVar`,Nat`},Boolean} .
  op $prepare-updates : List{SymbUpdate} Map{SymbVar,Nat} Boolean -> Tuple{Map`{SymbVar`,Nat`},Boolean} .
  eq prepare-updates(AsgL, VMp)
   = $prepare-updates(AsgL, VMp, true) .
  eq $prepare-updates(nil, VMp, B)
   = (VMp,B) .
  eq $prepare-updates(((B := B1) AsgL),
                         (v(B) |-> N, VMp),
                         B2)
   = $prepare-updates(AsgL,
                         (v(B) |-> s(N), VMp),
                         B2 and (process-expression((v(B) |-> s(N)), B) === process-expression((v(B) |-> N, VMp), B1))) .
  eq $prepare-updates(((I := I1) AsgL),
                         (v(I) |-> N, VMp),
                         B2)
   = $prepare-updates(AsgL,
                         (v(I) |-> s(N), VMp),
                         B2 and (process-expression((v(I) |-> s(N)), I) === process-expression((v(I) |-> N, VMp), I1))) .
  eq $prepare-updates(((R := R1) AsgL),
                         (v(R) |-> N, VMp),
                         B2)
   = $prepare-updates(AsgL,
                         (v(R) |-> s(N), VMp),
                         B2 and (process-expression((v(R) |-> s(N)), R) === process-expression((v(R) |-> N, VMp), R1))) .

  eq $prepare-updates(lookup(B) AsgL, (v(B) |-> N, VMp), B2)
   = $prepare-updates(AsgL, (v(B) |-> s(N), VMp), B2) .
  eq $prepare-updates(lookup(I) AsgL, (v(I) |-> N, VMp), B2)
   = $prepare-updates(AsgL, (v(I) |-> s(N), VMp), B2) .
  eq $prepare-updates(lookup(R) AsgL, (v(R) |-> N, VMp), B2)
   = $prepare-updates(AsgL, (v(R) |-> s(N), VMp), B2) .

  ---- Given a map of variable indices, the given expression is
  ---- rewriten to account for the current indices of the variables
  op process-expression : Map{SymbVar,Nat} Boolean -> Boolean [memo] .
  op process-expression : Map{SymbVar,Nat} Integer -> Integer [memo] .
  op process-expression : Map{SymbVar,Nat} Real -> Real [memo] .

  ---- Recursive definition on the term structure of Booleans,
  ---- integers, and reals for updating variable names according to
  ---- the information available from the index map

  ---- process Boolean expressions
  eq process-expression(VMp, not B1)
   = not process-expression(VMp,B1) .
  eq process-expression(VMp, B1 and B2)
   = process-expression(VMp,B1) and process-expression(VMp,B2) .
  eq process-expression(VMp, B1 xor B2)
   = process-expression(VMp,B1) xor process-expression(VMp,B2) .
  eq process-expression(VMp, B1 or B2)
   = process-expression(VMp,B1) or process-expression(VMp,B2) .
  eq process-expression(VMp, B1 implies B2)
   = process-expression(VMp,B1) implies process-expression(VMp,B2) .
  eq process-expression(VMp, B1 === B2)
   = process-expression(VMp,B1) === process-expression(VMp,B2) .
  eq process-expression(VMp, B1 =/== B2)
   = process-expression(VMp,B1) =/== process-expression(VMp,B2) .
  eq process-expression(VMp, B ? B1 : B2)
   = process-expression(VMp,B) ? process-expression(VMp,B1) : process-expression(VMp,B2) .
  eq process-expression((v(B) |-> N, VMp), B)
   = gen-bool-var(upTerm(B), N) .
  eq process-expression(VMp, B)
   = B [owise] .

  ---- process integer valued and related Boolean expressions
  eq process-expression(VMp, - I1)
   = (- process-expression(VMp, I1)) .
  eq process-expression(VMp, I1 + I2)
   = process-expression(VMp, I1) + process-expression(VMp, I2) .
  eq process-expression(VMp, I1 * I2)
   = process-expression(VMp, I1) * process-expression(VMp, I2) .
  eq process-expression(VMp, I1 - I2)
   = process-expression(VMp, I1) - process-expression(VMp, I2) .
  eq process-expression(VMp, I1 div I2)
   = process-expression(VMp, I1) div process-expression(VMp, I2) .
  eq process-expression(VMp, I1 mod I2)
   = process-expression(VMp, I1) mod process-expression(VMp, I2) .
  eq process-expression(VMp, I1 < I2)
   = process-expression(VMp, I1) < process-expression(VMp, I2) .
  eq process-expression(VMp, I1 <= I2)
   = process-expression(VMp, I1) <= process-expression(VMp, I2) .
  eq process-expression(VMp, I1 > I2)
   = process-expression(VMp, I1) > process-expression(VMp, I2) .
  eq process-expression(VMp, I1 >= I2)
   = process-expression(VMp, I1) >= process-expression(VMp, I2) .
  eq process-expression(VMp, I1 === I2)
   = process-expression(VMp, I1) === process-expression(VMp, I2) .
  eq process-expression(VMp, I1 =/== I2)
   = process-expression(VMp, I1) =/== process-expression(VMp, I2) .
  eq process-expression(VMp, B ? I1 : I2)
   = process-expression(VMp, B) ? process-expression(VMp, I1) : process-expression(VMp, I2) .
  eq process-expression((v(I) |-> N, VMp), I)
   = gen-int-var(upTerm(I), N) .
  eq process-expression(VMp, I)
   = I [owise] .

  ---- process real valued and related Boolean expressions
  eq process-expression(VMp, - R1)
   = (- process-expression(VMp, R1)) .
  eq process-expression(VMp, R1 + R2)
   = process-expression(VMp, R1) + process-expression(VMp, R2) .
  eq process-expression(VMp, R1 * R2)
   = process-expression(VMp, R1) * process-expression(VMp, R2) .
  eq process-expression(VMp, R1 - R2)
   = process-expression(VMp, R1) - process-expression(VMp, R2) .
  eq process-expression(VMp, R1 / R2)
   = process-expression(VMp, R1) / process-expression(VMp, R2) .
  eq process-expression(VMp, R1 < R2)
   = process-expression(VMp, R1) < process-expression(VMp, R2) .
  eq process-expression(VMp, R1 <= R2)
   = process-expression(VMp, R1) <= process-expression(VMp, R2) .
  eq process-expression(VMp, R1 > R2)
   = process-expression(VMp, R1) > process-expression(VMp, R2) .
  eq process-expression(VMp, R1 >= R2)
   = process-expression(VMp, R1) >= process-expression(VMp, R2) .
  eq process-expression(VMp, R1 === R2)
   = process-expression(VMp, R1) === process-expression(VMp, R2) .
  eq process-expression(VMp, R1 =/== R2)
   = process-expression(VMp, R1) =/== process-expression(VMp, R2) .
  eq process-expression(VMp, B ? R1 : R2)
   = process-expression(VMp, B) ? process-expression(VMp, R1) : process-expression(VMp, R2) .
  eq process-expression((v(R) |-> N, VMp), R)
   = gen-real-var(upTerm(R), N) .
  eq process-expression(VMp, R)
   = R [owise] .

  -----------------------------------
  ---- Split gateway - exclusive ----
  -----------------------------------
 crl [splitGatewayExclusive] :
     < PId : Process |
           nodes : (split(NId, exclusive, FId1, (LTIB1 (FId2,B2) LTIB2)), Nodes),
           flows : (flow(FId2, T), Flows),
           Atts >
     < SId : Simulation |
           tokens : (token(FId1, 0), Tks),
           constr : B,
           varidx : VMp,
           Atts1 >
  => < PId : Process |
           nodes : (split(NId, exclusive, FId1, (LTIB1 (FId2,B2) LTIB2)), Nodes),
           flows : (flow(FId2, T), Flows),
           Atts >
     < SId : Simulation |
           tokens : (token(FId2, T), Tks),
           constr : (B and B1),
           varidx : VMp,
           Atts1 >
  if B1 := process-expression(VMp, B2)
  /\ check-sat(B and B1)
     [print "splitExclusive " NId " B:" B " B2: " B2 " B1: " B1] .

  -----------------------------------
  ---- Merge gateway - exclusive ----
  -----------------------------------
  rl [mergeGatewayExclusive] :
      < PId : Process |
           nodes : (merge(NId, exclusive, (FId1, FIds), FId2), Nodes),
           flows : (flow(FId2, T), Flows),
           Atts >
      < SId : Simulation |
           tokens : (token(FId1, 0), Tks),
           Atts1 >
    =>
      < PId : Process |
           nodes : (merge(NId, exclusive, (FId1, FIds), FId2), Nodes),
           flows : (flow(FId2, T), Flows),
           Atts >
      < SId : Simulation |
           tokens : (token(FId2, T), Tks),
           Atts1 >
    [print "mergeExclusive " NId] .

  ----------------------------------
  ---- Split gateway - parallel ----
  ----------------------------------
  rl [splitGatewayParallel] :
      < PId : Process |
           nodes : (split(NId, parallel, FId, FIds), Nodes),
           flows : Flows,
           Atts >
      < SId : Simulation |
           tokens : (token(FId, 0), Tks),
           Atts1 >
    =>
      < PId : Process |
           nodes : (split(NId, parallel, FId, FIds), Nodes),
           flows : Flows,
           Atts >
      < SId : Simulation |
           tokens : (generateTokensSplitParallel(FIds, Flows), Tks),
           Atts1 >
    [print "splitParallel " NId] .

  ----------------------------------
  ---- Merge gateway - parallel ----
  ----------------------------------
  crl [mergeGatewayParallel] :
      < PId : Process |
           nodes : (merge(NId, parallel, (FId1, FIds), FId), Nodes),
           flows : (flow(FId, T), Flows),
           Atts >
      < SId : Simulation |
           tokens : (token(FId1, 0), Tks),
           Atts1 >
    =>
      < PId : Process |
           nodes : (merge(NId, parallel, (FId1, FIds), FId), Nodes),
           flows : (flow(FId, T), Flows),
           Atts >
      < SId : Simulation |
           tokens : (token(FId, T),
                     removeTokensParallel(FIds, Tks)),
           Atts1 >
    if allTokensParallel(FIds, Tks)
    [print "mergeParallel " NId] .

  -----------------------------------
  ---- Split gateway - inclusive ----
  -----------------------------------
 crl [splitGatewayInclusive] :
      < PId : Process |
           nodes : (split(NId, inclusive, FId, LTIB), Nodes),
           flows : Flows,
           Atts >
      < SId : Simulation |
           tokens : (token(FId, 0), Tks),
           constr : B,
           varidx : VMp,
           Atts1 >
    =>
      < PId : Process |
           nodes : (split(NId, inclusive, FId, LTIB), Nodes),
           flows : Flows,
           Atts >
      < SId : Simulation |
           tokens : (set-time(IL, Flows), Tks),
           constr : (B and B2),
           varidx : VMp,
           Atts1 >
    if ILL1 . IL . ILL2 := gen(project1(LTIB))
    /\ B1 := get-constr(IL, LTIB)
    /\ B2 := process-expression(VMp, B1)
    /\ check-sat(B and B2)
    [print "splitInclusive " IL ] .

  -----------------------------------
  ---- Merge gateway - inclusive ----
  -----------------------------------
  crl [mergeGatewayInclusive] :
      < PId : Process |
           nodes : (merge(NId, inclusive, (FId1, FIds), FId2), Nodes),
           flows : (flow(FId2, T), Flows),
           Atts >
      < SId : Simulation |
           tokens : (token(FId1, 0), Tks),
           Atts1 >
    =>
      < PId : Process |
           nodes : (merge(NId, inclusive, (FId1, FIds), FId2), Nodes),
           flows : (flow(FId2, T), Flows),
           Atts >
      < SId : Simulation |
           tokens : (token(FId2, T),
                     removeTokensInclusive(FIds, Tks)),
           Atts1 >
    if allTokensInclusive(FIds, Tks, (merge(NId, inclusive, (FId1, FIds), FId2), Nodes))
    [print "mergeInclusive " NId] .
endm
