mod UNIFICATION-TEST is
	sort Value .

	op Z : -> Value .
	op s : Value -> Value .
	op _plus_ : Value Value -> Value [assoc comm id: Z] .

	vars V V1 V2 : Value .
	--- eq V plus Z = V .
	eq V1 plus s(V2) = s(V1 plus V2) .
endm

unify V1:Value plus s(V2:Value) plus V3:Value =? s(s(s(Z))) .

mod UNIFICATION-SET-TEST is
	pr SET{Nat} .
endm

unify 0 , 1 , N:Nat , R:Set{Nat} =? 0 , 1 , 2 .

mod UNIFICATION-LIST-TEST is
	pr LIST{Nat} .
endm

unify 0 1 R:NeList{Nat} =? 0 1 2 .

mod NELIST{X :: TRIV} is
  protecting NAT .
  sorts NeList{X} .
  subsort X$Elt < NeList{X} .

  op __ : NeList{X} NeList{X} -> NeList{X} [ctor assoc prec 25] .
endm

mod UNIFICATION-NELIST-TEST is
	pr NELIST{Nat} .

    rl 0 NL:NeList{Nat} => NL:NeList{Nat} [narrowing] .
endm

unify 0 1 R:NeList{Nat} =? 0 1 2 .
vu-narrow N:Nat R:NeList{Nat} =>* R:NeList{Nat} .

eof

mod UNIFICATION-MAP-TEST is
	pr MAP{Nat,Nat} .

	rl N1:Nat |-> 0 , M:Map{Nat,Nat} => N1:Nat |-> undefined , M:Map{Nat,Nat} [narrowing] .
endm

unify N1:Nat |-> N2:Nat , M:Map{Nat,Nat} =? 1 |-> 2 .
vu-narrow E:Entry{Nat,Nat} , M:Map{Nat,Nat} =>* N1:Nat |-> undefined .

eof

(search [1] in NARROWING-TEST : plus(V1:Value, V2:Value) ~>! s(s(Z)) .)
