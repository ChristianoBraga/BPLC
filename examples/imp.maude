fmod TOKEN is
     pr QID-LIST .
     sorts Token Bubble TokenList NeTokenList .
     subsort Token < TokenList .

     op _,_ : TokenList TokenList -> TokenList [assoc prec 5] .

     op token : Qid -> Token
        [special
          (id-hook Bubble        (1 1)
           op-hook qidSymbol     (<Qids> : ~> Qid)
	id-hook Exclude       ( print ))] .

    op bubble : QidList -> Bubble
        [special
          (id-hook Bubble        (1 -1)
        op-hook qidListSymbol (__ : QidList QidList ~> QidList)
        op-hook qidSymbol     (<Qids> : ~> Qid)  
	id-hook Exclude       ( OR IF THEN ELSE END BEGIN WHILE ; := = skip )
	  ) ] .
    
    op neTokenList : QidList -> NeTokenList
        [special
          (id-hook Bubble        (1 -1)
        op-hook qidListSymbol (__ : QidList QidList ~> QidList)
        op-hook qidSymbol     (<Qids> : ~> Qid)
        id-hook Exclude       ( . ))] .
endfm

fmod IMP-GRAMMAR is
    pr TOKEN .
    pr RAT .

    sorts VariablesDecl ConstantsDecl OperationsDecl OperationDeclList
        OperationDecl FormalsDecl BlockCommandDecl CommandDecl ExpressionDecl
        ValueDecl ValueDeclList ValuesDecl PredicateDecl ClausesDecl
        ModuleDecl Expression .

    subsort ValueDecl < ValueDeclList .
    subsort VariablesDecl ConstantsDecl OperationsDecl ValuesDecl < ClausesDecl .
	subsort BlockCommandDecl < CommandDecl .
    subsort OperationDecl < OperationDeclList .
    subsort PredicateDecl < ExpressionDecl .
	
    --- IMP BOOLEAN EXPRESSIONS
    ops true false : -> PredicateDecl .
    op _==_ : Token Token -> PredicateDecl [prec 30] .
    op _==_ : Token ExpressionDecl -> PredicateDecl [prec 30] .
    op _==_ : ExpressionDecl Token -> PredicateDecl [prec 30] .
    op _==_ : ExpressionDecl ExpressionDecl -> PredicateDecl [prec 30] .
    op _/\_ : PredicateDecl PredicateDecl -> PredicateDecl [assoc comm prec 35] .
    op ~ : PredicateDecl -> PredicateDecl .

	--- IMP ARITHMETIC EXPRESSIONS
    op _+_ : Token Token -> ExpressionDecl [gather(e E) prec 15] .
    op _+_ : Token ExpressionDecl -> ExpressionDecl [gather(e E) prec 15] .
    op _+_ : ExpressionDecl Token -> ExpressionDecl [gather(e E) prec 15] .
    op _+_ : ExpressionDecl ExpressionDecl -> ExpressionDecl [gather(e E) prec 15] .

    op _-_ : Token Token -> ExpressionDecl  [gather(e E) prec 15] .
    op _-_ : Token ExpressionDecl -> ExpressionDecl [gather(e E) prec 15] .
    op _-_ : ExpressionDecl Token -> ExpressionDecl [gather(e E) prec 15] .
    op _-_ : ExpressionDecl ExpressionDecl -> ExpressionDecl [gather(e E) prec 15] .

    op _*_ : Token Token -> ExpressionDecl [gather(e E) prec 10] .
    op _*_ : Token ExpressionDecl -> ExpressionDecl [gather(e E) prec 10] .
    op _*_ : ExpressionDecl Token -> ExpressionDecl [gather(e E) prec 10] .
    op _*_ : ExpressionDecl ExpressionDecl -> ExpressionDecl [gather(e E) prec 10] .

    op _/_ : Token Token -> ExpressionDecl [prec 20] .
    op _/_ : Token ExpressionDecl -> ExpressionDecl [prec 20] .
    op _/_ : ExpressionDecl Token -> ExpressionDecl [prec 20] .
    op _/_ : ExpressionDecl ExpressionDecl -> ExpressionDecl [prec 20] .	

    --- IMP COMMANDS
    op _:=_ : Token Token -> CommandDecl [prec 40] .
    op _:=_ : Token ExpressionDecl -> CommandDecl [prec 40] .

    op _() : Token -> CommandDecl .	
    op _(_) : Token Bubble -> CommandDecl .
    op print : Token -> CommandDecl .
    op print : ExpressionDecl -> CommandDecl .
    op nop : -> CommandDecl .
    op _;_ : CommandDecl CommandDecl -> CommandDecl [assoc prec 50] .
    op _|_ : CommandDecl CommandDecl -> CommandDecl [assoc prec 50] .
    op while_do_ : PredicateDecl BlockCommandDecl -> CommandDecl [prec 40] .
    op {_} : CommandDecl -> BlockCommandDecl [prec 35] .
    op if_then_end : PredicateDecl CommandDecl -> CommandDecl [prec 40] .
    op if_then_else_end : PredicateDecl BlockCommandDecl BlockCommandDecl -> CommandDecl [prec 40] .
	
    --- IMP DECLARATIONS
	op module__end : Token ClausesDecl -> ModuleDecl [prec 80] .
    op __ : ClausesDecl ClausesDecl -> ClausesDecl [assoc comm prec 70] .
    op var_ : TokenList -> VariablesDecl [prec 60] .
    op const_ : TokenList -> ConstantsDecl [prec 60] .
    op init_ : ValueDecl -> ValuesDecl [prec 60] .
    op init_ : ValueDeclList -> ValuesDecl  [prec 60] .
    op _=_ : Token Token -> ValueDecl  [prec 40] .
    op _=_ : Token ExpressionDecl -> ValueDecl  [prec 40] .
    op _,_ : ValueDeclList ValueDeclList -> ValueDeclList  [assoc prec 50] .
    op proc__ : Token BlockCommandDecl -> OperationDecl [prec 50] .
    op proc_`(_`)_ : Token TokenList BlockCommandDecl -> OperationDecl  [prec 50] .
    op __ : OperationDeclList OperationDeclList -> OperationDeclList  [assoc prec 60] .	
endfm

load bplc

mod IMP-TO-BPLC is
    inc IMP-GRAMMAR .
    pr BPLC .
	pr META-LEVEL .

    op id : Token -> Id [ctor] .

    op compile : Token -> Id .

    eq compile('token[I:Qid]) = 
       if (metaParse(upModule('RAT, false), downTerm(I:Qid, 'Qid), 'Rat)  :: ResultPair)
	   then grat(downTerm(getTerm(metaParse(upModule('RAT, false),
		    downTerm(I:Qid, 'Qid), 'Rat)), 1/2))
	   else
	     if (metaParse(upModule('BOOL, false), downTerm(I:Qid, 'Qid), 'Bool) :: ResultPair) 
	     then gboo(downTerm(getTerm(metaParse(upModule('BOOL, false),
		      downTerm(I:Qid, 'Qid), 'Bool)), true))
	     else processPreIdentifiers(I:Qid) 
	     fi 
	   fi .

    --- GSLExpressions
    eq compile(token(T:Qid)) = id(T:Qid) .

    eq compile(grat(R:Rat)) = rat(R:Rat) .

    eq compile(gboo(B:Bool)) = boo(B:Bool) .

    eq compile(E1:GSLExpression @+ E2:GSLExpression) =
	add(compile(E1:GSLExpression), compile(E2:GSLExpression)) .

    eq compile(E1:GSLExpression - E2:GSLExpression) =
	sub(compile(E1:GSLExpression), compile(E2:GSLExpression)) .

    eq compile(E1:GSLExpression * E2:GSLExpression) =
	mul(compile(E1:GSLExpression), compile(E2:GSLExpression)) .

    eq compile(E1:GSLExpression / E2:GSLExpression) =
	div(compile(E1:GSLExpression), compile(E2:GSLExpression)) .

    --- GSLPredicates
    eq compile(E1:GSLExpression == E2:GSLExpression) =
	eq(compile(E1:GSLExpression), compile(E2:GSLExpression)) .

    eq compile(E1:GSLExpression >= E2:GSLExpression) =
	ge(compile(E1:GSLExpression), compile(E2:GSLExpression)) .

    eq compile(E1:GSLExpression > E2:GSLExpression) =
	gt(compile(E1:GSLExpression), compile(E2:GSLExpression)) .

    eq compile(E1:GSLExpression <= E2:GSLExpression) =
	le(compile(E1:GSLExpression), compile(E2:GSLExpression)) .

    eq compile(E1:GSLExpression < E2:GSLExpression) =
	lt(compile(E1:GSLExpression), compile(E2:GSLExpression)) .

    eq compile(~ E:GSLExpression) =
	neg(compile(E:GSLExpression)) .

    eq compile(E1:GSLExpression /\ E2:GSLExpression) =
	and(compile(E1:GSLExpression), compile(E2:GSLExpression)) .

    eq compile(E1:GSLExpression \/ E2:GSLExpression) =
	or(compile(E1:GSLExpression), compile(E2:GSLExpression)) .

    --- skip
    eq compile(skip) = nop .

    --- Simple assignment
    eq compile(V:GSLIdentifiers @:= E:GSLExpression) =
	assign(compile(V:GSLIdentifiers), compile(E:GSLExpression)) .

    --- Pre-condition
    eq compile(P:GSLPredicate | S:GSLSubstitution) =
	if(compile(P:GSLPredicate), compile(S:GSLSubstitution), exit(rat(0))) .

      --- Bounded choice
    eq compile(S1:GSLSubstitution [] S2:GSLSubstitution) =
	choice(compile(S1:GSLSubstitution), compile(S2:GSLSubstitution)) .

    --- Guarded GSLSubstitution
    eq compile(P:GSLPredicate ==> S:GSLSubstitution) =
	if(compile(P:GSLPredicate), compile(S:GSLSubstitution), nop) .

    --- TODO:
    --- Unbounded choice

    --- Sequences
    eq compile(S1:GSLSubstitution ; S2:GSLSubstitution) =
	seq(compile(S1:GSLSubstitution), compile(S2:GSLSubstitution)) .

    --- Conditional

    eq compile(IF P:GSLPredicate THEN S1:GSLSubstitution ELSE
	  S2:GSLSubstitution END) = if(compile(P:GSLPredicate),
	  compile(S1:GSLSubstitution), compile(S2:GSLSubstitution)) .

	--- While
    eq compile(WHILE P:GSLPredicate DO S:GSLSubstitution) =
	loop(compile(P:GSLPredicate), compile(S:GSLSubstitution)) .

    --- Print
    eq compile(@print (E:GSLExpression)) = print(compile(E:GSLExpression)) .
endm

eof

fmod PROCESS-AMN-DECL is
    inc TOKEN .
    inc AMN-SYNTAX .
    pr META-LEVEL .
    pr CONVERSION .
    
    op processPreMachine : Term ~> AMNMachine .
    eq processPreMachine('MACHINE__END['token[I:Qid], T:Term]) =
        MACHINE processPreIdentifiers(I:Qid) processPreClauses(T:Term) END .

    op processPreClauses : Term ~> AMNClauses .
    op processPreClauses : TermList ~> AMNClauses .
    eq processPreClauses('VARIABLES_['token[I:Qid]]) =
        VARIABLES processPreIdentifiers(I:Qid) .

    eq processPreClauses('VARIABLES_['_`,_[IS:TermList]]) =
        VARIABLES processPreVariableList(IS:TermList) .

    eq processPreClauses('CONSTANTS_['token[I:Qid]]) =
        CONSTANTS processPreIdentifiers(I:Qid) .

    eq processPreClauses('CONSTANTS_['_`,_[IS:TermList]]) =
        CONSTANTS processPreVariableList(IS:TermList) .

    eq processPreClauses('VALUES_['_=_[TL:TermList]]) =
        VALUES processPreValueDecl('_=_[TL:TermList]) .

    eq processPreClauses('VALUES_['_;_[TL:TermList]]) =
        VALUES processPreValueDeclList(TL:TermList) .

    eq processPreClauses('OPERATIONS_['_=_[TL:TermList]]) =
        OPERATIONS processPreOperationDecl('_=_[TL:TermList]) .

    eq processPreClauses('OPERATIONS_['_`(_`)=_[TL:TermList]]) =
        OPERATIONS processPreOperationDecl('_`(_`)=_[TL:TermList]) .

    eq processPreClauses('OPERATIONS_['_;_[OS:TermList]]) =
        OPERATIONS processPreOperationDeclList(OS:TermList) .

    eq processPreClauses('__[TL:TermList]) =
        processPreClauses(TL:TermList) .

    eq processPreClauses((T:Term, TL:TermList)) =
        processPreClauses(T:Term) processPreClauses(TL:TermList) .

    op processPreValueDecl : Term ~> AMNValuation .
    eq processPreValueDecl('_=_['token[I:Qid], T:Term]) =
        processPreIdentifiers(I:Qid) @= processPreExpression(T:Term) .

    eq processPreValueDecl('_;_[T:Term, TL:NeTermList]) =
        processPreValueDecl(T:Term) ;
        processPreValueDeclList(TL:NeTermList) .

    op processPreValueDeclList : TermList ~> AMNValSet .
    eq processPreValueDeclList(T:Term) = processPreValueDecl(T:Term) .

    eq processPreValueDeclList((T:Term, TL:NeTermList)) =
        processPreValueDecl(T:Term) ;
        processPreValueDeclList(TL:NeTermList) .

    op processPreOperationDecl : Term ~> AMNOperation .
    eq processPreOperationDecl('_=_['token[O:Qid], T:Term]) =
        (processPreIdentifiers(O:Qid) =
          processPreSubstitution(T:Term)) .

    eq processPreOperationDecl('_`(_`)=_['token[O:Qid], TL:TermList, T:Term]) =
        (processPreIdentifiers(O:Qid) (processPreVariableList(TL:TermList)) =
          processPreSubstitution(T:Term)) .

    op processPreOperationDeclList : TermList ~> AMNOpSet .

    ceq processPreOperationDeclList(F:Qid[TL:TermList]) =
         processPreOperationDecl(F:Qid[TL:TermList]) if F:Qid =/= '_;_ .

    eq processPreOperationDeclList('_;_[OS:TermList]) =
        processPreOperationDeclList(OS:TermList) .

    eq processPreOperationDeclList((T:Term, TL:NeTermList)) =
        processPreOperationDecl(T:Term) ;
        processPreOperationDeclList(TL:NeTermList) .

    op processPreVariableList : TermList ~> AMNIdList .
    eq processPreVariableList('token[I:Qid]) = processPreIdentifiers(I:Qid) .
    eq processPreVariableList('_`,_['token[I1:Qid] , 'token[I2:Qid]]) =
        processPreIdentifiers(I1:Qid) @, processPreIdentifiers(I2:Qid) .

    eq processPreVariableList('_`,_['token[I:Qid] , TL:TermList]) =
        processPreIdentifiers(I:Qid) @,
        processPreVariableList(TL:TermList) .
    eq processPreVariableList(('token[I:Qid] , TL:TermList)) =
        processPreIdentifiers(I:Qid) @,
        processPreVariableList(TL:TermList) .

    op processPreIdentifiers : Qid -> GSLIdentifiers .
    ceq processPreIdentifiers(I:Qid) = bid(downTerm(I:Qid, 'processPreIdentifiersError))
      if downTerm(I:Qid, 'processPreIdentifiersError) =/= 'processPreIdentifiersError .
    
    op processPreSubstitution : Term -> GSLSubstitution .

    eq processPreSubstitution('skip.SubstitutionDecl) = (skip).GSLSubstitution .

    eq processPreSubstitution('_:=_['token[I:Qid], T:Term]) =
        (processPreIdentifiers(I:Qid) @:= processPreExpression(T:Term)) .

    ---     eq processPreSubstitution('token[I:Qid]) = (processPreIdentifiers(I:Qid) ()) .

    eq processPreSubstitution('_`(`)['token[I:Qid]]) =
        (processPreIdentifiers(I:Qid) ()) .

    eq processPreSubstitution('_`(_`)['token[I:Qid], 'bubble[Q:Qid]]) =
   	(processPreIdentifiers(I:Qid) (processPreActuals(Q:Qid))) .
    
    eq processPreSubstitution('_`(_`)['token[I:Qid], 'bubble['__[TL:TermList]]]) =
	(processPreIdentifiers(I:Qid) (processPreActuals(TL:TermList))) .
    
    op processPreActuals : TermList -> GSLActuals .	
    eq processPreActuals(Q:Qid) = processPreExpression(Q:Qid) .
    eq processPreActuals((TL1:TermList, ''`,.Qid , TL2:TermList)) = 
	makeGSLExpression(TL1:TermList) , processPreActuals(TL2:TermList) .
    eq processPreActuals(TL:TermList) = makeGSLExpression(TL:TermList) [owise] .
    
    op makeGSLExpression : TermList -> GSLExpression .
    eq makeGSLExpression(Q:Qid) = processPreExpression(Q:Qid) .

    ceq makeGSLExpression(TL:TermList) =
	processPreExpression(getTerm(metaParse(upModule('AMN-GRAMMAR,
	false), makeExprDeclQidList(TL:TermList), 'ExpressionDecl)))
    if (metaParse(upModule('AMN-GRAMMAR, false),
	makeExprDeclQidList(TL:TermList), 'ExpressionDecl) ::
	ResultPair) .

    op makeExprDeclQidList : TermList -> QidList .
    eq makeExprDeclQidList((empty).TermList) = (nil).QidList .
    ceq makeExprDeclQidList(Q:Qid) = downTerm(Q:Qid, 'error)
    if downTerm(Q:Qid, 'error) =/= 'error .
    eq makeExprDeclQidList((Q:Qid , TL:TermList)) = 
	makeExprDeclQidList(Q:Qid) makeExprDeclQidList(TL:TermList) .
    
    eq processPreSubstitution('IF_THEN_END[T1:Term, T2:Term]) =
	IF processPrePredicate(T1:Term)
	THEN processPreSubstitution(T2:Term) END .

    eq processPreSubstitution('print[T:Term]) =
        @print(processPreExpression(T:Term)) .

    eq processPreSubstitution('IF_THEN_ELSE_END[T1:Term, T2:Term, T3:Term]) =
        IF processPrePredicate(T1:Term)
        THEN processPreSubstitution(T2:Term)
        ELSE processPreSubstitution(T3:Term)
        END .

    eq processPreSubstitution('_|_[T1:Term, T2:Term]) =
        processPrePredicate(T1:Term) | processPreSubstitution(T2:Term) .

    eq processPreSubstitution('WHILE_DO_[T1:Term, T2:Term]) =
        WHILE processPrePredicate(T1:Term)
        DO processPreSubstitution(T2:Term) .

    eq processPreSubstitution('BEGIN_END[T:Term]) =
        BEGIN processPreSubstitution(T:Term) END .

    eq processPreSubstitution('_;_[T1:Term, T2:Term]) =
        processPreSubstitution(T1:Term) ;
        processPreSubstitution(T2:Term) .

    eq processPreSubstitution('_OR_[T1:Term, T2:Term]) =
        processPreSubstitution(T1:Term) OR
        processPreSubstitution(T2:Term) .

    op processPreExpression : Qid -> GSLExpression .

    eq processPreExpression(I:Qid) = 
        if (metaParse(upModule('RAT, false), downTerm(I:Qid, 'Qid), 'Rat)  :: ResultPair)
	then grat(downTerm(getTerm(metaParse(upModule('RAT, false),
		  downTerm(I:Qid, 'Qid), 'Rat)), 1/2))
	else
	if metaParse(upModule('RAT, false), downTerm(I:Qid, 'Qid), 'Bool) :: ResultPair 
	  then gboo(downTerm(getTerm(metaParse(upModule('BOOL, false),
		    downTerm(I:Qid, 'Qid), 'Bool)), true))
	  else processPreIdentifiers(I:Qid) 
	  fi 
	fi .
    
    op processPreExpression : Term -> GSLExpression .
    eq processPreExpression('token[I:Qid]) = 
        if (metaParse(upModule('RAT, false), downTerm(I:Qid, 'Qid), 'Rat)  :: ResultPair)
	then grat(downTerm(getTerm(metaParse(upModule('RAT, false),
		  downTerm(I:Qid, 'Qid), 'Rat)), 1/2))
	else
	if metaParse(upModule('RAT, false), downTerm(I:Qid, 'Qid), 'Bool) :: ResultPair 
	  then gboo(downTerm(getTerm(metaParse(upModule('BOOL, false),
		    downTerm(I:Qid, 'Qid), 'Bool)), true))
	  else processPreIdentifiers(I:Qid) 
	  fi 
	fi .

    eq processPreExpression('_+_[T1:Term, T2:Term]) =
        processPreExpression(T1:Term) @+ processPreExpression(T2:Term) .

    eq processPreExpression('_-_[T1:Term, T2:Term]) =
        processPreExpression(T1:Term) - processPreExpression(T2:Term) .

    eq processPreExpression('_*_[T1:Term, T2:Term]) =
        processPreExpression(T1:Term) * processPreExpression(T2:Term) .

    eq processPreExpression('_/_[T1:Term, T2:Term]) =
        processPreExpression(T1:Term) / processPreExpression(T2:Term) .

    op processPrePredicate : Term ~> GSLPredicate .
    eq processPrePredicate('true.PredicateDecl) = gboo(true) .
    eq processPrePredicate('false.PredicateDecl) = gboo(false) .
    eq processPrePredicate('token[I:Qid]) = processPreIdentifiers(I:Qid) .
    eq processPrePredicate('~[T:Term]) =
        ~ processPrePredicate(T:Term) .
    eq processPrePredicate('_/\_[T1:Term,T2:Term]) =
        processPrePredicate(T1:Term) /\ processPrePredicate(T2:Term) .
    eq processPrePredicate('_==_[T1:Term,T2:Term]) =
        processPreExpression(T1:Term) == processPreExpression(T2:Term) .
endfm

fmod AMN-SYNTAX is
     ex GSL-SYNTAX .
     sorts AMNMachine AMNClauses AMNAbsVariables AMNAbsConstants
        AMNOperations AMNValuesClause AMNValuation AMNValSet AMNIdList
        AMNOperation AMNOpSet GSLActuals .

    subsort AMNAbsVariables AMNAbsConstants AMNOperations
	    AMNValuesClause < AMNClauses .

    subsort GSLIdentifiers < AMNIdList .
    subsort AMNValuation < AMNValSet .
    subsort AMNOperation < AMNOpSet .
    subsort GSLExpression < GSLActuals .
    
    op _,_ : GSLActuals GSLActuals -> GSLActuals [assoc] .

    op MACHINE_END : GSLIdentifiers -> AMNMachine .
    op MACHINE__END : GSLIdentifiers AMNClauses -> AMNMachine
        [prec 40 format(b!++ o o --nib! o)] .

    op __ : AMNClauses AMNClauses -> AMNClauses [ctor assoc comm prec 30] .
    op VARIABLES_ : AMNIdList -> AMNAbsVariables [ctor prec 25 format(nib! o o)] .
    op CONSTANTS_ : AMNIdList -> AMNAbsConstants [ctor prec 25 format(nib! o o)] .
    op _@,_ : AMNIdList AMNIdList -> AMNIdList [ctor assoc prec 10 format(o b! o o o)] .

    op VALUES_ : AMNValSet -> AMNValuesClause [ctor prec 25 format(nib! o++ o--)] .

    op _@=_ : GSLIdentifiers GSLExpression -> AMNValuation [ctor prec
	  10 format(nio b! o o)] .

    op _;_ : AMNValSet AMNValSet ->
    AMNValSet [ctor assoc comm prec 15 format(o b! o o)] .

    op OPERATIONS_ : AMNOpSet -> AMNOperations [ctor prec 25 format(nib! o++ o--)] .
    op _=_ : GSLIdentifiers GSLSubstitution -> AMNOperation
        [ctor prec 15 format(nio b! o++ o--)] .
    op _;_ : AMNOpSet AMNOpSet -> AMNOpSet [ctor assoc comm prec 20 format(o b! o o)] .
    op _(_)=_ : GSLIdentifiers AMNIdList GSLSubstitution -> AMNOperation
        [prec 20 format(o b! o b! b! o o)] .

--- TODO:
***(op _<-_(_)=_ : GSLIdentifiers GSLIdentifiers GSLSubstitution -> AMNOperation
    [prec 20 format(o b! o b! o o)] .
)
    op _(_) : GSLIdentifiers GSLActuals -> GSLSubstitution
        [prec 20 ctor format(b! o b! o o)] .
    op _() : GSLIdentifiers -> GSLSubstitution
        [prec 20 ctor format(b! b! o o)] .
endfm

mod AMN-TO-BPLC is
    ex AMN-SYNTAX .
    ex GSL-TO-BPLC .

    op compile : AMNMachine -> Dec .
    op compile : AMNClauses -> Dec .
    op compile : AMNAbsVariables AMNValuesClause -> Dec .
    op compileToRef : AMNIdList AMNValSet -> Dec .
    op compile : AMNAbsConstants AMNValuesClause -> Dec .
    op compileToCns : AMNIdList AMNValSet -> Dec .
    op compile : AMNOperations -> Dec .
    op compile : AMNOpSet -> Dec .
    op compile : GSLIdentifiers -> Id .
    op compileToFormals : AMNIdList -> Formals .

    --- AMNOperation call
    eq compile(I:GSLIdentifiers (E:GSLExpression)) =
	cal(compile(I:GSLIdentifiers), compile(E:GSLExpression)) .

    eq compile(I:GSLIdentifiers ()) =
	cal(compile(I:GSLIdentifiers)) .

    eq compile(I:GSLIdentifiers (A:GSLActuals)) =
	cal(compile(I:GSLIdentifiers), compile(A:GSLActuals)) .

    op compile : GSLActuals -> Actuals .

    eq compile(A1:GSLActuals, A2:GSLActuals) =
	act(compile(A1:GSLActuals), compile(A2:GSLActuals)) .

    --- GSLIdentifiers
    eq compile(P:GSLIdentifiers) = gid(P:GSLIdentifiers) .

    --- AMNOperations
    --- TODO: AMNOperation with return value.
    eq compile(P:GSLIdentifiers = S:GSLSubstitution) =
	prc(compile(P:GSLIdentifiers), blk(compile(S:GSLSubstitution))) .

    eq compile(P:GSLIdentifiers (FS:AMNIdList) = S:GSLSubstitution) =
	prc(compile(P:GSLIdentifiers),
          compileToFormals(FS:AMNIdList), blk(compile(S:GSLSubstitution))) .
    eq compileToFormals(F:GSLIdentifiers) = par(compile(F:GSLIdentifiers)) .
    eq compileToFormals(F:GSLIdentifiers @, FS:AMNIdList) =
	for(compileToFormals(F:GSLIdentifiers), compileToFormals(FS:AMNIdList)) .

    eq compile(O:AMNOperation ; OS:AMNOpSet) =
	dec(compile(O:AMNOperation), compile(OS:AMNOpSet)) .
    eq compile(OPERATIONS O:AMNOperation) = compile(O:AMNOperation) .
    eq compile(OPERATIONS OS:AMNOpSet) = compile(OS:AMNOpSet) .

    --- Variables
    eq compile(VARIABLES IS:AMNIdList, VALUES VS:AMNValSet) =
	compileToRef(IS:AMNIdList, VS:AMNValSet) .

    eq compileToRef(I:GSLIdentifiers , (I:GSLIdentifiers @= E:GSLExpression)) =
	ref(compile(I:GSLIdentifiers), compile(E:GSLExpression)) .

    eq compileToRef((I:GSLIdentifiers) ,
          ((I:GSLIdentifiers @= E:GSLExpression) ; VS:AMNValSet)) =
	ref(compile(I:GSLIdentifiers), compile(E:GSLExpression)) .

    eq compileToRef((I:GSLIdentifiers @, IS:AMNIdList) ,
          ((I:GSLIdentifiers @= E:GSLExpression) ; VS:AMNValSet)) =
	dec(ref(compile(I:GSLIdentifiers), compile(E:GSLExpression)),
          compileToRef(IS:AMNIdList, VS:AMNValSet)) .

    --- Constants
    eq compile(CONSTANTS IS:AMNIdList, VALUES VS:AMNValSet) =
	compileToCns(IS:AMNIdList, VS:AMNValSet) .

    eq compileToCns(I:GSLIdentifiers , (I:GSLIdentifiers @= E:GSLExpression)) =
	cns(compile(I:GSLIdentifiers), compile(E:GSLExpression)) .

    eq compileToCns((I:GSLIdentifiers) ,
          ((I:GSLIdentifiers @= E:GSLExpression) ; VS:AMNValSet)) =
	cns(compile(I:GSLIdentifiers), compile(E:GSLExpression)) .

    eq compileToCns((I:GSLIdentifiers @, IS:AMNIdList) ,
          ((I:GSLIdentifiers @= E:GSLExpression) ; VS:AMNValSet)) =
	dec(cns(compile(I:GSLIdentifiers), compile(E:GSLExpression)),
          compileToCns(IS:AMNIdList, VS:AMNValSet)) .

    --- AMNMachine

    eq compile( MACHINE I:GSLIdentifiers A:AMNAbsVariables
          C:AMNAbsConstants VS:AMNValuesClause OP:AMNOperations END) =
          dec(compile(A:AMNAbsVariables, VS:AMNValuesClause),
           dec(compile(C:AMNAbsConstants, VS:AMNValuesClause),
             compile(OP:AMNOperations))) .

    eq compile( MACHINE I:GSLIdentifiers A:AMNAbsVariables
          VS:AMNValuesClause OP:AMNOperations END) =
          dec(compile(A:AMNAbsVariables, VS:AMNValuesClause),
           compile(OP:AMNOperations)) .

    eq compile( MACHINE I:GSLIdentifiers C:AMNAbsConstants
          VS:AMNValuesClause OP:AMNOperations END) =
          dec(compile(C:AMNAbsConstants, VS:AMNValuesClause),
           compile(OP:AMNOperations)) .
    
    eq compile( MACHINE I:GSLIdentifiers OP:AMNOperations END) =
          compile(OP:AMNOperations) .
endm
